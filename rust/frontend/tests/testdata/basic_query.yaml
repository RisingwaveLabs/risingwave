- sql: values (11, 22), (33+(1+2), 44);
  plan: |
    LogicalValues { rows: [[11:Int32, 22:Int32], [Add(33:Int32, Add(1:Int32, 2:Int32)), 44:Int32]], schema: Schema { fields: [:Int32, :Int32] } }

- sql: select * from t
  binder_error: "Item not found: relation \"t\""

- sql: |
    create table t (v1 bigint, v2 double precision);
    select * from t;
  plan: |
    LogicalProject { exprs: [$0, $1, $2], expr_alias: [None, None, None] }
      LogicalScan { table: "t", columns: ["_row_id", "v1", "v2"] }

- sql: |
    create table t ();
    select * from t where 1>2 and 1=1 and 3<1 and 4<>1 or 1=1 and 2>=1 and 1<=2;
  plan: |
    LogicalProject { exprs: [$0], expr_alias: [None] }
      LogicalFilter { predicate: Condition { conjunctions: [Or(And(And(And(GreaterThan(1:Int32, 2:Int32), Equal(1:Int32, 1:Int32)), LessThan(3:Int32, 1:Int32)), NotEqual(4:Int32, 1:Int32)), And(And(Equal(1:Int32, 1:Int32), GreaterThanOrEqual(2:Int32, 1:Int32)), LessThanOrEqual(1:Int32, 2:Int32)))] } }
        LogicalScan { table: "t", columns: ["_row_id"] }

- sql: |
    create table t (v1 int);
    select * from t where v1<1;
  plan: |
    LogicalProject { exprs: [$0, $1], expr_alias: [None, None] }
      LogicalFilter { predicate: Condition { conjunctions: [LessThan($1, 1:Int32)] } }
        LogicalScan { table: "t", columns: ["_row_id", "v1"] }

- sql: |
    create table t (v1 int, v2 int);
    insert into t values (22, 33), (44, 55);
  plan: |
    LogicalInsert { table_name: t, columns: [] }
      LogicalValues { rows: [[22:Int32, 33:Int32], [44:Int32, 55:Int32]], schema: Schema { fields: [:Int32, :Int32] } }

- sql: |
    create table t ();
    SELECT (((((false is not true) is true) is not false) is false) is not null) is null FROM t;
  plan: |
    LogicalProject { exprs: [FunctionCall(FunctionCall { func_type: IsNull, return_type: Boolean, inputs: [FunctionCall(FunctionCall { func_type: IsNotNull, return_type: Boolean, inputs: [FunctionCall(FunctionCall { func_type: IsFalse, return_type: Boolean, inputs: [FunctionCall(FunctionCall { func_type: IsNotFalse, return_type: Boolean, inputs: [FunctionCall(FunctionCall { func_type: IsTrue, return_type: Boolean, inputs: [FunctionCall(FunctionCall { func_type: IsNotTrue, return_type: Boolean, inputs: [Literal(Literal { data: Some(Bool(false)), data_type: Boolean })] })] })] })] })] })] })], expr_alias: [None] }
      LogicalScan { table: "t", columns: ["_row_id"] }

- sql: |
    create table t (v1 int);
    SELECT (CASE WHEN v1 < 60 THEN 1 WHEN v1 >= 80 THEN 1.0 ELSE 1 END) FROM t;
  plan: |
    LogicalProject { exprs: [FunctionCall(FunctionCall { func_type: Case, return_type: Decimal, inputs: [FunctionCall(FunctionCall { func_type: LessThan, return_type: Boolean, inputs: [InputRef(1), Literal(Literal { data: Some(Int32(60)), data_type: Int32 })] }), FunctionCall(FunctionCall { func_type: GreaterThanOrEqual, return_type: Boolean, inputs: [InputRef(1), Literal(Literal { data: Some(Int32(80)), data_type: Int32 })] }), Literal(Literal { data: Some(Int32(1)), data_type: Int32 }), Literal(Literal { data: Some(Decimal(Normalized(1.0))), data_type: Decimal }), Literal(Literal { data: Some(Int32(1)), data_type: Int32 })] })], expr_alias: [None] }
      LogicalScan { table: "t", columns: ["_row_id", "v1"] }

- sql: |
    create table t (v1 int);
    SELECT (CASE v1 WHEN 60 THEN 1 WHEN 80 THEN 1.0 ELSE 1 END) FROM t;
  plan: |
    LogicalProject { exprs: [FunctionCall(FunctionCall { func_type: Case, return_type: Decimal, inputs: [FunctionCall(FunctionCall { func_type: Equal, return_type: Boolean, inputs: [InputRef(1), Literal(Literal { data: Some(Int32(60)), data_type: Int32 })] }), FunctionCall(FunctionCall { func_type: Equal, return_type: Boolean, inputs: [InputRef(1), Literal(Literal { data: Some(Int32(80)), data_type: Int32 })] }), Literal(Literal { data: Some(Int32(1)), data_type: Int32 }), Literal(Literal { data: Some(Decimal(Normalized(1.0))), data_type: Decimal }), Literal(Literal { data: Some(Int32(1)), data_type: Int32 })] })], expr_alias: [None] }
      LogicalScan { table: "t", columns: ["_row_id", "v1"] }

# Because the order in which these column appear in `exprs` is random, I comment this test.
# - sql: |
#     create table t (v1 varchar);
#     select * from t where length(v1)=2 and v1 like '12' and length(upper(v1))=1 and length(lower(v1))=1 is true;
#   plan: |
#     LogicalProject { exprs: [InputRef(1), InputRef(0)], expr_alias: [None, None] }
#       LogicalFilter { predicate: Condition { conjunctions: [FunctionCall(FunctionCall { func_type: Equal, return_type: Boolean, inputs: [FunctionCall(FunctionCall { func_type: Length, return_type: Int32, inputs: [InputRef(1)] }), Literal(Literal { data: Some(Int32(2)), data_type: Int32 })] }), FunctionCall(FunctionCall { func_type: Like, return_type: Boolean, inputs: [InputRef(1), Literal(Literal { data: Some(Utf8("12")), data_type: Varchar })] }), FunctionCall(FunctionCall { func_type: Equal, return_type: Boolean, inputs: [FunctionCall(FunctionCall { func_type: Length, return_type: Int32, inputs: [FunctionCall(FunctionCall { func_type: Upper, return_type: Varchar, inputs: [InputRef(1)] })] }), Literal(Literal { data: Some(Int32(1)), data_type: Int32 })] }), FunctionCall(FunctionCall { func_type: IsTrue, return_type: Boolean, inputs: [FunctionCall(FunctionCall { func_type: Equal, return_type: Boolean, inputs: [FunctionCall(FunctionCall { func_type: Length, return_type: Int32, inputs: [FunctionCall(FunctionCall { func_type: Lower, return_type: Varchar, inputs: [InputRef(1)] })] }), Literal(Literal { data: Some(Int32(1)), data_type: Int32 })] })] })] } }
#         LogicalScan { table: "t", columns: ["_row_id", "v1"] }

- sql: |
    create table t (v1 int, v2 int);
    select v1 from t;
  plan: |
    LogicalProject { exprs: [$1], expr_alias: [None] }
      LogicalScan { table: "t", columns: ["_row_id", "v1", "v2"] }

- sql: |
    values(cast(1 as bigint));
  plan: |
    LogicalValues { rows: [[1:Int32::Int64]], schema: Schema { fields: [:Int64] } }

- sql: |
    values(not true);
  plan: |
    LogicalValues { rows: [[Not(true:Boolean)]], schema: Schema { fields: [:Boolean] } }

- sql: |
    values(must_be_unimplemented_func(1));
  binder_error: |
    Feature is not yet implemented: unsupported function: Ident { value: "must_be_unimplemented_func", quote_style: None }

- sql: |
    values(sum(1));
  binder_error: |
    Invalid input syntax: aggregate functions are not allowed in VALUES

- sql: |
    values(count(1));
  binder_error: |
    Invalid input syntax: aggregate functions are not allowed in VALUES

- sql: |
    values(min(1));
  binder_error: |
    Invalid input syntax: aggregate functions are not allowed in VALUES

- sql: |
    values(max(1));
  binder_error: |
    Invalid input syntax: aggregate functions are not allowed in VALUES

# Nested aggregate function.
- sql: |
    values(1 + max(1));
  binder_error: |
    Invalid input syntax: aggregate functions are not allowed in VALUES

- sql: |
    create table t (v1 int);
    select v1 from t where min(v1);
  binder_error: |
    Invalid input syntax: aggregate functions are not allowed in WHERE

# Inner join
- sql: |
    create table t1 (v1 int, v2 int);
    create table t2 (v1 int, v2 int);
    create table t3 (v1 int, v2 int);
    select * from t1 join t2 on (t1.v1 = t2.v1) join t3 on (t2.v2 = t3.v2);
  plan: |
    LogicalProject { exprs: [$0, $1, $2, $3, $4, $5, $6, $7, $8], expr_alias: [None, None, None, None, None, None, None, None, None] }
      LogicalJoin { type: Inner, on: Condition { conjunctions: [Equal($5, $8)] } }
        LogicalJoin { type: Inner, on: Condition { conjunctions: [Equal($1, $4)] } }
          LogicalScan { table: "t1", columns: ["_row_id", "v1", "v2"] }
          LogicalScan { table: "t2", columns: ["_row_id", "v1", "v2"] }
        LogicalScan { table: "t3", columns: ["_row_id", "v1", "v2"] }
