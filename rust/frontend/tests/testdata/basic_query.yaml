- sql: values (11, 22), (33+(1+2), 44);
  plan: |
    LogicalValues { rows: [[Literal(Literal { data: Some(Int32(11)), data_type: Int32 }), Literal(Literal { data: Some(Int32(22)), data_type: Int32 })], [FunctionCall(FunctionCall { func_type: Add, return_type: Int32, inputs: [Literal(Literal { data: Some(Int32(33)), data_type: Int32 }), FunctionCall(FunctionCall { func_type: Add, return_type: Int32, inputs: [Literal(Literal { data: Some(Int32(1)), data_type: Int32 }), Literal(Literal { data: Some(Int32(2)), data_type: Int32 })] })] }), Literal(Literal { data: Some(Int32(44)), data_type: Int32 })]], schema: Schema { fields: [Field { name = , data_type = Int32 }, Field { name = , data_type = Int32 }] } }

- sql: select * from t
  binder_error: "Item not found: relation \"t\""

# Because the order in which these column appear in `exprs` is random, I comment this test. I 
# - sql: |
#     create table t (v1 bigint, v2 double precision);
#     select * from t;
#   plan: |
#     LogicalProject { exprs: [InputRef(1), InputRef(0), InputRef(2)], expr_alias: [None, None, None] }
#       LogicalScan { table: "t", columns: ["_row_id", "v1", "v2"] }

- sql: |
    create table t (v1 int, v2 int);
    insert into t values (22, 33), (44, 55);
  plan: |
    LogicalInsert { table_name: t, columns: [] }
      LogicalValues { rows: [[Literal(Literal { data: Some(Int32(22)), data_type: Int32 }), Literal(Literal { data: Some(Int32(33)), data_type: Int32 })], [Literal(Literal { data: Some(Int32(44)), data_type: Int32 }), Literal(Literal { data: Some(Int32(55)), data_type: Int32 })]], schema: Schema { fields: [Field { name = , data_type = Int32 }, Field { name = , data_type = Int32 }] } }

- sql: |
    create table t (v1 int, v2 int);
    select v1 from t;
  plan: |
    LogicalProject { exprs: [InputRef(1)], expr_alias: [None] }
      LogicalScan { table: "t", columns: ["_row_id", "v1", "v2"] }

- sql: |
    values(cast(1 as int));
  plan: |
    LogicalValues { rows: [[FunctionCall(FunctionCall { func_type: Cast, return_type: Int32, inputs: [Literal(Literal { data: Some(Int32(1)), data_type: Int32 })] })]], schema: Schema { fields: [Field { name = , data_type = Int32 }] } }

- sql: |
    values(not true);
  plan: |
    LogicalValues { rows: [[FunctionCall(FunctionCall { func_type: Not, return_type: Boolean, inputs: [Literal(Literal { data: Some(Bool(true)), data_type: Boolean })] })]], schema: Schema { fields: [Field { name = , data_type = Boolean }] } }

- sql: |
    values(must_be_unimplemented_func(1));
  binder_error: |
    Feature is not yet implemented: unsupported function: Ident { value: "must_be_unimplemented_func", quote_style: None }

- sql: |
    values(sum(1));
  binder_error: |
    Invalid input syntax: aggregate functions are not allowed in VALUES

- sql: |
    values(count(1));
  binder_error: |
    Invalid input syntax: aggregate functions are not allowed in VALUES

- sql: |
    values(min(1));
  binder_error: |
    Invalid input syntax: aggregate functions are not allowed in VALUES

- sql: |
    values(max(1));
  binder_error: |
    Invalid input syntax: aggregate functions are not allowed in VALUES

