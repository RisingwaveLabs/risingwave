- sql: |-
    values (11, 22), (33+(1+2), 44);
  batch_plan: |
    BatchValues { rows: [[11:Int32, 22:Int32], [(33:Int32 + (1:Int32 + 2:Int32)), 44:Int32]] }
- sql: |-
    select * from t
  binder_error: |-
    Item not found: relation "t"
- sql: |
    create table t (v1 bigint, v2 double precision);
    select * from t;
  batch_plan: |
    BatchProject { exprs: [$0, $1, $2], expr_alias: [Some("_row_id"), Some("v1"), Some("v2")] }
      BatchScan { table: "t", columns: ["_row_id", "v1", "v2"] }
  stream_plan: |
    StreamProject { exprs: [$0, $1, $2], expr_alias: [Some("_row_id"), Some("v1"), Some("v2")] }
      StreamScan { logical: LogicalScan { base: LogicalBase { id: PlanNodeId(9), schema: Schema { fields: [_row_id:Int64, v1:Int64, v2:Float64] }, ctx: RefCell { value: QueryContext { current id = 14 } } }, table_name: "t", table_id: TableId { table_id: 0 }, columns: [ColumnId(0), ColumnId(1), ColumnId(2)] } }
- sql: |
    create table t (v1 bigint, v2 double precision);
    select t2.* from t;
  binder_error: |-
    Item not found: relation "t2"
- sql: |
    create table t ();
    select * from t where 1>2 and 1=1 and 3<1 and 4<>1 or 1=1 and 2>=1 and 1<=2;
  batch_plan: |
    BatchProject { exprs: [$0], expr_alias: [Some("_row_id")] }
      BatchFilter { predicate: Condition { conjunctions: [(((((1:Int32 > 2:Int32) AND (1:Int32 = 1:Int32)) AND (3:Int32 < 1:Int32)) AND (4:Int32 <> 1:Int32)) OR (((1:Int32 = 1:Int32) AND (2:Int32 >= 1:Int32)) AND (1:Int32 <= 2:Int32)))] } }
        BatchScan { table: "t", columns: ["_row_id"] }
  stream_plan: |
    StreamProject { exprs: [$0], expr_alias: [Some("_row_id")] }
      StreamFilter { predicate: Condition { conjunctions: [(((((1:Int32 > 2:Int32) AND (1:Int32 = 1:Int32)) AND (3:Int32 < 1:Int32)) AND (4:Int32 <> 1:Int32)) OR (((1:Int32 = 1:Int32) AND (2:Int32 >= 1:Int32)) AND (1:Int32 <= 2:Int32)))] } }
        StreamScan { logical: LogicalScan { base: LogicalBase { id: PlanNodeId(15), schema: Schema { fields: [_row_id:Int64] }, ctx: RefCell { value: QueryContext { current id = 23 } } }, table_name: "t", table_id: TableId { table_id: 0 }, columns: [ColumnId(0)] } }
- sql: |
    create table t (v1 int);
    select * from t where v1<1;
  batch_plan: |
    BatchProject { exprs: [$0, $1], expr_alias: [Some("_row_id"), Some("v1")] }
      BatchFilter { predicate: Condition { conjunctions: [($1 < 1:Int32)] } }
        BatchScan { table: "t", columns: ["_row_id", "v1"] }
  stream_plan: |
    StreamProject { exprs: [$0, $1], expr_alias: [Some("_row_id"), Some("v1")] }
      StreamFilter { predicate: Condition { conjunctions: [($1 < 1:Int32)] } }
        StreamScan { logical: LogicalScan { base: LogicalBase { id: PlanNodeId(15), schema: Schema { fields: [_row_id:Int64, v1:Int32] }, ctx: RefCell { value: QueryContext { current id = 23 } } }, table_name: "t", table_id: TableId { table_id: 0 }, columns: [ColumnId(0), ColumnId(1)] } }
- sql: |
    create table t (v1 int, v2 int);
    insert into t values (22, 33), (44, 55);
  batch_plan: |
    BatchInsert { table_name: "t", columns: [] }
      BatchValues { rows: [[22:Int32, 33:Int32], [44:Int32, 55:Int32]] }
- sql: |
    create table t (v1 int, v2 int);
    delete from t where v1 = 1;
  batch_plan: |
    BatchDelete { table_name: "t" }
      BatchFilter { predicate: Condition { conjunctions: [($1 = 1:Int32)] } }
        BatchScan { table: "t", columns: ["_row_id", "v1", "v2"] }
- sql: |
    create table t (v1 int, v2 int);
    delete from t;
  batch_plan: |
    BatchDelete { table_name: "t" }
      BatchScan { table: "t", columns: ["_row_id", "v1", "v2"] }
- sql: |
    create table t (v1 int, v2 int);
    select v1 from t;
  batch_plan: |
    BatchProject { exprs: [$0], expr_alias: [Some("v1")] }
      BatchScan { table: "t", columns: ["v1"] }
  stream_plan: |
    StreamProject { exprs: [$0], expr_alias: [Some("v1")] }
      StreamScan { logical: LogicalScan { base: LogicalBase { id: PlanNodeId(9), schema: Schema { fields: [v1:Int32] }, ctx: RefCell { value: QueryContext { current id = 14 } } }, table_name: "t", table_id: TableId { table_id: 0 }, columns: [ColumnId(1)] } }
- sql: |
    values(cast(1 as bigint));
  batch_plan: |
    BatchValues { rows: [[1:Int32::Int64]] }
- sql: |
    values(not true);
  batch_plan: |
    BatchValues { rows: [[Not(true:Boolean)]] }
- sql: |
    values(must_be_unimplemented_func(1));
  binder_error: |-
    Feature is not yet implemented: unsupported function: Ident { value: "must_be_unimplemented_func", quote_style: None }
- sql: |
    values(sum(1));
  binder_error: |-
    Invalid input syntax: aggregate functions are not allowed in VALUES
- sql: |
    values(count(1));
  binder_error: |-
    Invalid input syntax: aggregate functions are not allowed in VALUES
- sql: |
    values(min(1));
  binder_error: |-
    Invalid input syntax: aggregate functions are not allowed in VALUES
- sql: |
    values(1 + max(1));
  binder_error: |-
    Invalid input syntax: aggregate functions are not allowed in VALUES
- sql: |
    create table t (v1 int);
    select v1 from t where min(v1);
  binder_error: |-
    Invalid input syntax: aggregate functions are not allowed in WHERE
- sql: |
    create table t1 (v1 int, v2 int);
    create table t2 (v1 int, v2 int);
    create table t3 (v1 int, v2 int);
    select * from t1 join t2 on (t1.v1 = t2.v1) join t3 on (t2.v2 = t3.v2);
  batch_plan: |
    BatchProject { exprs: [$0, $1, $2, $3, $4, $5, $6, $7, $8], expr_alias: [Some("_row_id"), Some("v1"), Some("v2"), Some("_row_id"), Some("v1"), Some("v2"), Some("_row_id"), Some("v1"), Some("v2")] }
      BatchHashJoin(predicate: $5 = $8)
        BatchHashJoin(predicate: $1 = $4)
          BatchScan { table: "t1", columns: ["_row_id", "v1", "v2"] }
          BatchScan { table: "t2", columns: ["_row_id", "v1", "v2"] }
        BatchScan { table: "t3", columns: ["_row_id", "v1", "v2"] }
  stream_plan: |
    StreamProject { exprs: [$0, $1, $2, $3, $4, $5, $6, $7, $8], expr_alias: [Some("_row_id"), Some("v1"), Some("v2"), Some("_row_id"), Some("v1"), Some("v2"), Some("_row_id"), Some("v1"), Some("v2")] }
      StreamHashJoin(predicate: $5 = $8)
        StreamHashJoin(predicate: $1 = $4)
          StreamScan { logical: LogicalScan { base: LogicalBase { id: PlanNodeId(27), schema: Schema { fields: [_row_id:Int64, v1:Int32, v2:Int32] }, ctx: RefCell { value: QueryContext { current id = 42 } } }, table_name: "t1", table_id: TableId { table_id: 0 }, columns: [ColumnId(0), ColumnId(1), ColumnId(2)] } }
          StreamScan { logical: LogicalScan { base: LogicalBase { id: PlanNodeId(28), schema: Schema { fields: [_row_id:Int64, v1:Int32, v2:Int32] }, ctx: RefCell { value: QueryContext { current id = 42 } } }, table_name: "t2", table_id: TableId { table_id: 1 }, columns: [ColumnId(0), ColumnId(1), ColumnId(2)] } }
        StreamScan { logical: LogicalScan { base: LogicalBase { id: PlanNodeId(30), schema: Schema { fields: [_row_id:Int64, v1:Int32, v2:Int32] }, ctx: RefCell { value: QueryContext { current id = 42 } } }, table_name: "t3", table_id: TableId { table_id: 2 }, columns: [ColumnId(0), ColumnId(1), ColumnId(2)] } }
- sql: |
    create table t1 (v1 int not null, v2 int not null);
    create table t2 (v1 int not null, v2 int not null);
    select t1.v2, t2.v2 from t1 join t2 on t1.v1 = t2.v1;
  batch_plan: |
    BatchProject { exprs: [$1, $3], expr_alias: [Some("v2"), Some("v2")] }
      BatchHashJoin(predicate: $0 = $2)
        BatchScan { table: "t1", columns: ["v1", "v2"] }
        BatchScan { table: "t2", columns: ["v1", "v2"] }
  stream_plan: |
    StreamProject { exprs: [$1, $3], expr_alias: [Some("v2"), Some("v2")] }
      StreamHashJoin(predicate: $0 = $2)
        StreamScan { logical: LogicalScan { base: LogicalBase { id: PlanNodeId(19), schema: Schema { fields: [v1:Int32, v2:Int32] }, ctx: RefCell { value: QueryContext { current id = 30 } } }, table_name: "t1", table_id: TableId { table_id: 0 }, columns: [ColumnId(1), ColumnId(2)] } }
        StreamScan { logical: LogicalScan { base: LogicalBase { id: PlanNodeId(20), schema: Schema { fields: [v1:Int32, v2:Int32] }, ctx: RefCell { value: QueryContext { current id = 30 } } }, table_name: "t2", table_id: TableId { table_id: 1 }, columns: [ColumnId(1), ColumnId(2)] } }
- sql: |-
    select 1
  batch_plan: |
    BatchProject { exprs: [1:Int32], expr_alias: [None] }
      BatchValues { rows: [[]] }
