- sql: |-
    values (11, 22), (33+(1+2), 44);
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchValues { rows: [[11:Int32, 22:Int32], [(33:Int32 + (1:Int32 + 2:Int32)), 44:Int32]] }
- sql: |-
    select * from t
  binder_error: |-
    Item not found: relation "t"
- sql: |
    create table t (v1 bigint, v2 double precision);
    select * from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [$0, $1, $2], expr_alias: [Some("_row_id"), Some("v1"), Some("v2")] }
        BatchScan { table: t, columns: [_row_id, v1, v2] }
  stream_plan: |
    StreamMaterialize { table_id: 0 }
      StreamProject { exprs: [$0, $1, $2], expr_alias: [Some("_row_id"), Some("v1"), Some("v2")] }
        StreamExchange { dist: Single }
          StreamTableScan { table: t, columns: [_row_id, v1, v2] }
- sql: |
    create table t (v1 bigint, v2 double precision);
    select t2.* from t;
  binder_error: |-
    Item not found: relation "t2"
- sql: |
    create table t ();
    select * from t where 1>2 and 1=1 and 3<1 and 4<>1 or 1=1 and 2>=1 and 1<=2;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [$0], expr_alias: [Some("_row_id")] }
        BatchFilter { predicate: (((((1:Int32 > 2:Int32) AND (1:Int32 = 1:Int32)) AND (3:Int32 < 1:Int32)) AND (4:Int32 <> 1:Int32)) OR (((1:Int32 = 1:Int32) AND (2:Int32 >= 1:Int32)) AND (1:Int32 <= 2:Int32))) }
          BatchScan { table: t, columns: [_row_id] }
  stream_plan: |
    StreamMaterialize { table_id: 0 }
      StreamProject { exprs: [$0], expr_alias: [Some("_row_id")] }
        StreamExchange { dist: Single }
          StreamFilter { predicate: (((((1:Int32 > 2:Int32) AND (1:Int32 = 1:Int32)) AND (3:Int32 < 1:Int32)) AND (4:Int32 <> 1:Int32)) OR (((1:Int32 = 1:Int32) AND (2:Int32 >= 1:Int32)) AND (1:Int32 <= 2:Int32))) }
            StreamTableScan { table: t, columns: [_row_id] }
- sql: |
    create table t (v1 int);
    select * from t where v1<1;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [$0, $1], expr_alias: [Some("_row_id"), Some("v1")] }
        BatchFilter { predicate: ($1 < 1:Int32) }
          BatchScan { table: t, columns: [_row_id, v1] }
  stream_plan: |
    StreamMaterialize { table_id: 0 }
      StreamProject { exprs: [$0, $1], expr_alias: [Some("_row_id"), Some("v1")] }
        StreamExchange { dist: Single }
          StreamFilter { predicate: ($1 < 1:Int32) }
            StreamTableScan { table: t, columns: [_row_id, v1] }
- sql: |
    create table t ();
    select (((((false is not true) is true) is not false) is false) is not null) is null from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [IsNull(IsNotNull(IsFalse(IsNotFalse(IsTrue(IsNotTrue(false:Boolean))))))], expr_alias: [None] }
        BatchScan { table: t, columns: [] }
  stream_plan: |
    StreamMaterialize { table_id: 0 }
      StreamProject { exprs: [IsNull(IsNotNull(IsFalse(IsNotFalse(IsTrue(IsNotTrue(false:Boolean))))))], expr_alias: [None] }
        StreamExchange { dist: Single }
          StreamTableScan { table: t, columns: [] }
- sql: |
    create table t (v1 int);
    select (case when v1=1 then 1 when v1=2 then 2 else 0.0 end) from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [Case(($0 = 1:Int32), 1:Int32::Decimal, ($0 = 2:Int32), 2:Int32::Decimal, Normalized(0.0):Decimal)], expr_alias: [None] }
        BatchScan { table: t, columns: [v1] }
  stream_plan: |
    StreamMaterialize { table_id: 0 }
      StreamProject { exprs: [Case(($0 = 1:Int32), 1:Int32::Decimal, ($0 = 2:Int32), 2:Int32::Decimal, Normalized(0.0):Decimal)], expr_alias: [None] }
        StreamExchange { dist: Single }
          StreamTableScan { table: t, columns: [v1] }
- sql: |
    create table t (v1 int, v2 int);
    insert into t values (22, 33), (44, 55);
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchInsert { table_name: "t", columns: [] }
        BatchValues { rows: [[22:Int32, 33:Int32], [44:Int32, 55:Int32]] }
- sql: |
    create table t (v1 int, v2 int);
    delete from t where v1 = 1;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchDelete { table_name: "t" }
        BatchFilter { predicate: ($1 = 1:Int32) }
          BatchScan { table: t, columns: [_row_id, v1, v2] }
- sql: |
    create table t (v1 int, v2 int);
    delete from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchDelete { table_name: "t" }
        BatchScan { table: t, columns: [_row_id, v1, v2] }
- sql: |
    create table t (v1 int, v2 int);
    select v1 from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [$0], expr_alias: [Some("v1")] }
        BatchScan { table: t, columns: [v1] }
  stream_plan: |
    StreamMaterialize { table_id: 0 }
      StreamProject { exprs: [$0], expr_alias: [Some("v1")] }
        StreamExchange { dist: Single }
          StreamTableScan { table: t, columns: [v1] }
- sql: |
    values(cast(1 as bigint));
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchValues { rows: [[1:Int32::Int64]] }
- sql: |
    values(not true);
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchValues { rows: [[Not(true:Boolean)]] }
- sql: |
    values(must_be_unimplemented_func(1));
  binder_error: |-
    Feature is not yet implemented: unsupported function: Ident { value: "must_be_unimplemented_func", quote_style: None }
- sql: |
    values(sum(1));
  binder_error: |-
    Invalid input syntax: aggregate functions are not allowed in VALUES
- sql: |
    values(count(1));
  binder_error: |-
    Invalid input syntax: aggregate functions are not allowed in VALUES
- sql: |
    values(min(1));
  binder_error: |-
    Invalid input syntax: aggregate functions are not allowed in VALUES
- sql: |
    values(1 + max(1));
  binder_error: |-
    Invalid input syntax: aggregate functions are not allowed in VALUES
- sql: |
    create table t (v1 int);
    select v1 from t where min(v1);
  binder_error: |-
    Invalid input syntax: aggregate functions are not allowed in WHERE
- sql: |
    create table t1 (v1 int, v2 int);
    create table t2 (v1 int, v2 int);
    create table t3 (v1 int, v2 int);
    select * from t1 join t2 on (t1.v1 = t2.v1) join t3 on (t2.v2 = t3.v2);
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [$0, $1, $2, $3, $4, $5, $6, $7, $8], expr_alias: [Some("_row_id"), Some("v1"), Some("v2"), Some("_row_id"), Some("v1"), Some("v2"), Some("_row_id"), Some("v1"), Some("v2")] }
        BatchHashJoin { type: Inner, predicate: $5 = $8 }
          BatchExchange { order: [], dist: HashShard([5]) }
            BatchHashJoin { type: Inner, predicate: $1 = $4 }
              BatchExchange { order: [], dist: HashShard([1]) }
                BatchScan { table: t1, columns: [_row_id, v1, v2] }
              BatchExchange { order: [], dist: HashShard([4]) }
                BatchScan { table: t2, columns: [_row_id, v1, v2] }
          BatchExchange { order: [], dist: HashShard([8]) }
            BatchScan { table: t3, columns: [_row_id, v1, v2] }
  stream_plan: |
    StreamMaterialize { table_id: 0 }
      StreamProject { exprs: [$0, $1, $2, $3, $4, $5, $6, $7, $8], expr_alias: [Some("_row_id"), Some("v1"), Some("v2"), Some("_row_id"), Some("v1"), Some("v2"), Some("_row_id"), Some("v1"), Some("v2")] }
        StreamExchange { dist: Single }
          StreamHashJoin { type: Inner, predicate: $5 = $8 }
            StreamExchange { dist: HashShard([5]) }
              StreamHashJoin { type: Inner, predicate: $1 = $4 }
                StreamExchange { dist: HashShard([1]) }
                  StreamTableScan { table: t1, columns: [_row_id, v1, v2] }
                StreamExchange { dist: HashShard([4]) }
                  StreamTableScan { table: t2, columns: [_row_id, v1, v2] }
            StreamExchange { dist: HashShard([8]) }
              StreamTableScan { table: t3, columns: [_row_id, v1, v2] }
- sql: |
    create table t1 (v1 int not null, v2 int not null);
    create table t2 (v1 int not null, v2 int not null);
    select t1.v2, t2.v2 from t1 join t2 on t1.v1 = t2.v1;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [$1, $3], expr_alias: [Some("v2"), Some("v2")] }
        BatchHashJoin { type: Inner, predicate: $0 = $2 }
          BatchExchange { order: [], dist: HashShard([0]) }
            BatchScan { table: t1, columns: [v1, v2] }
          BatchExchange { order: [], dist: HashShard([2]) }
            BatchScan { table: t2, columns: [v1, v2] }
  stream_plan: |
    StreamMaterialize { table_id: 0 }
      StreamProject { exprs: [$1, $3], expr_alias: [Some("v2"), Some("v2")] }
        StreamExchange { dist: Single }
          StreamHashJoin { type: Inner, predicate: $0 = $2 }
            StreamExchange { dist: HashShard([0]) }
              StreamTableScan { table: t1, columns: [v1, v2] }
            StreamExchange { dist: HashShard([2]) }
              StreamTableScan { table: t2, columns: [v1, v2] }
- sql: |-
    select 1
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [1:Int32], expr_alias: [None] }
        BatchValues { rows: [[]] }
- sql: |
    create table t(v1 int, v2 int, v3 int);
    select v1, min(v2) + max(v3) * count(v1) from t group by v1;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [$0, ($1 + ($2 * $3))], expr_alias: [Some("v1"), None] }
        BatchHashAgg { group_keys: [0], aggs: [Min(1), Max(2), Count(3)] }
          BatchExchange { order: [], dist: HashShard([0]) }
            BatchProject { exprs: [$0, $1, $2, $0], expr_alias: [None, None, None, None] }
              BatchScan { table: t, columns: [v1, v2, v3] }
  stream_plan: |
    StreamMaterialize { table_id: 0 }
      StreamProject { exprs: [$0, ($1 + ($2 * $3))], expr_alias: [Some("v1"), None] }
        StreamExchange { dist: Single }
          StreamHashAgg { group_keys: [0], aggs: [Min(1), Max(2), Count(3)] }
            StreamProject { exprs: [$0, $1, $2, $0], expr_alias: [None, None, None, None] }
              StreamTableScan { table: t, columns: [v1, v2, v3] }
- sql: |
    create table t(v1 int, v2 int, v3 int);
    select min(v1) + max(v2) * count(v3) from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [($0 + ($1 * $2))], expr_alias: [None] }
        BatchSimpleAgg { aggs: [Min(0), Max(1), Count(2)] }
          BatchExchange { order: [], dist: Single }
            BatchProject { exprs: [$0, $1, $2], expr_alias: [None, None, None] }
              BatchScan { table: t, columns: [v1, v2, v3] }
  stream_plan: |
    StreamMaterialize { table_id: 0 }
      StreamProject { exprs: [($0 + ($1 * $2))], expr_alias: [None] }
        StreamExchange { dist: Single }
          StreamSimpleAgg { aggs: [Min(0), Max(1), Count(2)] }
            StreamProject { exprs: [$0, $1, $2], expr_alias: [None, None, None] }
              StreamTableScan { table: t, columns: [v1, v2, v3] }
- sql: |
    create table t(v1 int, v2 int);
    select v1 from t group by v2;
  planner_error: |-
    Invalid input syntax: column must appear in the GROUP BY clause or be used in an aggregate function
- sql: |
    create table t(v1 int, v2 int, v3 int);
    select v3, min(v1) * avg(v1+v2) from t group by v3;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [$0, ($1 * ($2 / $3))], expr_alias: [Some("v3"), None] }
        BatchHashAgg { group_keys: [0], aggs: [Min(1), Sum(2), Count(2)] }
          BatchExchange { order: [], dist: HashShard([0]) }
            BatchProject { exprs: [$2, $0, ($0 + $1)], expr_alias: [None, None, None] }
              BatchScan { table: t, columns: [v1, v2, v3] }
  stream_plan: |
    StreamMaterialize { table_id: 0 }
      StreamProject { exprs: [$0, ($1 * ($2 / $3))], expr_alias: [Some("v3"), None] }
        StreamExchange { dist: Single }
          StreamHashAgg { group_keys: [0], aggs: [Min(1), Sum(2), Count(2)] }
            StreamProject { exprs: [$2, $0, ($0 + $1)], expr_alias: [None, None, None] }
              StreamTableScan { table: t, columns: [v1, v2, v3] }
