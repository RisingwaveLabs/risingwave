- sql: |
    create table t (v1 int, v2 int);
    delete from t;
  batch_plan: |
    BatchDelete { table_name: "t" }
      BatchScan { table: t, columns: [_row_id, v1, v2] }
- sql: |
    create table t (v1 int, v2 int);
    select v1 from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [$0], expr_alias: [v1] }
        BatchScan { table: t, columns: [v1] }
  stream_plan: |
    StreamMaterialize { table_id: 0, column_order: [$0 ASC], column_id: [#0], pk_indices: [0] }
      StreamProject { exprs: [$0], expr_alias: [v1] }
        StreamTableScan { table: t, columns: [v1], pk_indices: [0] }
- sql: |
    values(cast(1 as bigint));
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchValues { rows: [[1:Int32::Int64]] }
- sql: |
    values(not true);
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchValues { rows: [[Not(true:Boolean)]] }
- sql: |
    values(must_be_unimplemented_func(1));
  binder_error: 'Feature is not yet implemented: unsupported function: Ident { value: "must_be_unimplemented_func", quote_style: None }'
- sql: |
    values(sum(1));
  binder_error: 'Invalid input syntax: aggregate functions are not allowed in VALUES'
- sql: |
    values(count(1));
  binder_error: 'Invalid input syntax: aggregate functions are not allowed in VALUES'
- sql: |
    values(min(1));
  binder_error: 'Invalid input syntax: aggregate functions are not allowed in VALUES'
- sql: |
    values(1 + max(1));
  binder_error: 'Invalid input syntax: aggregate functions are not allowed in VALUES'
- sql: |
    create table t (v1 int);
    select v1 from t where min(v1);
  binder_error: 'Invalid input syntax: aggregate functions are not allowed in WHERE'
- sql: |
    create table t1 (v1 int, v2 int);
    create table t2 (v1 int, v2 int);
    create table t3 (v1 int, v2 int);
    select * from t1 join t2 on (t1.v1 = t2.v1) join t3 on (t2.v2 = t3.v2);
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchHashJoin { type: Inner, predicate: $5 = $8 }
        BatchExchange { order: [], dist: HashShard([5]) }
          BatchHashJoin { type: Inner, predicate: $1 = $4 }
            BatchExchange { order: [], dist: HashShard([1]) }
              BatchScan { table: t1, columns: [_row_id, v1, v2] }
            BatchExchange { order: [], dist: HashShard([4]) }
              BatchScan { table: t2, columns: [_row_id, v1, v2] }
        BatchExchange { order: [], dist: HashShard([8]) }
          BatchScan { table: t3, columns: [_row_id, v1, v2] }
  stream_plan: |
    StreamMaterialize { table_id: 0, column_order: [$0 ASC, $3 ASC, $6 ASC], column_id: [#0, #1, #2, #3, #4, #5, #6, #7, #8], pk_indices: [0, 3, 6] }
      StreamExchange { dist: Single }
        StreamHashJoin { type: Inner, predicate: $5 = $8 }
          StreamExchange { dist: HashShard([5]) }
            StreamHashJoin { type: Inner, predicate: $1 = $4 }
              StreamExchange { dist: HashShard([1]) }
                StreamTableScan { table: t1, columns: [_row_id, v1, v2], pk_indices: [0] }
              StreamExchange { dist: HashShard([4]) }
                StreamTableScan { table: t2, columns: [_row_id, v1, v2], pk_indices: [0] }
          StreamExchange { dist: HashShard([8]) }
            StreamTableScan { table: t3, columns: [_row_id, v1, v2], pk_indices: [0] }
- sql: |
    create table t1 (v1 int not null, v2 int not null);
    create table t2 (v1 int not null, v2 int not null);
    select t1.v2, t2.v2 from t1 join t2 on t1.v1 = t2.v1;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [$1, $3], expr_alias: [v2, v2] }
        BatchHashJoin { type: Inner, predicate: $0 = $2 }
          BatchExchange { order: [], dist: HashShard([0]) }
            BatchScan { table: t1, columns: [v1, v2] }
          BatchExchange { order: [], dist: HashShard([2]) }
            BatchScan { table: t2, columns: [v1, v2] }
  stream_plan: |
    StreamMaterialize { table_id: 0, column_order: [], column_id: [#0, #1], pk_indices: [] }
      StreamProject { exprs: [$1, $3], expr_alias: [v2, v2] }
        StreamExchange { dist: Single }
          StreamHashJoin { type: Inner, predicate: $0 = $2 }
            StreamExchange { dist: HashShard([0]) }
              StreamTableScan { table: t1, columns: [v1, v2], pk_indices: [0] }
            StreamExchange { dist: HashShard([2]) }
              StreamTableScan { table: t2, columns: [v1, v2], pk_indices: [0] }
- sql: select 1
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [1:Int32], expr_alias: [ ] }
        BatchValues { rows: [[]] }
- sql: |
    create table t(v1 int, v2 int, v3 int);
    select v1, min(v2) + max(v3) * count(v1) from t group by v1;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [$0, ($1 + ($2 * $3))], expr_alias: [v1,  ] }
        BatchHashAgg { group_keys: [$0], aggs: [min($1), max($2), count($3)] }
          BatchExchange { order: [], dist: HashShard([0]) }
            BatchProject { exprs: [$0, $1, $2, $0], expr_alias: [ ,  ,  ,  ] }
              BatchScan { table: t, columns: [v1, v2, v3] }
  stream_plan: |
    StreamMaterialize { table_id: 0, column_order: [$0 ASC], column_id: [#0, #1], pk_indices: [0] }
      StreamProject { exprs: [$0, ($1 + ($2 * $3))], expr_alias: [v1,  ] }
        StreamExchange { dist: Single }
          StreamHashAgg { group_keys: [$0], aggs: [min($1), max($2), count($3)] }
            StreamProject { exprs: [$0, $1, $2, $0], expr_alias: [ ,  ,  ,  ] }
              StreamExchange { dist: HashShard([0]) }
                StreamTableScan { table: t, columns: [v1, v2, v3], pk_indices: [0] }
- sql: |
    create table t(v1 int, v2 int, v3 int);
    select min(v1) + max(v2) * count(v3) from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [($0 + ($1 * $2))], expr_alias: [ ] }
        BatchSimpleAgg { aggs: [min($0), max($1), count($2)] }
          BatchExchange { order: [], dist: Single }
            BatchProject { exprs: [$0, $1, $2], expr_alias: [ ,  ,  ] }
              BatchScan { table: t, columns: [v1, v2, v3] }
  stream_plan: |
    StreamMaterialize { table_id: 0, column_order: [], column_id: [#0], pk_indices: [] }
      StreamProject { exprs: [($0 + ($1 * $2))], expr_alias: [ ] }
        StreamExchange { dist: Single }
          StreamSimpleAgg { aggs: [min($0), max($1), count($2)] }
            StreamProject { exprs: [$0, $1, $2], expr_alias: [ ,  ,  ] }
              StreamTableScan { table: t, columns: [v1, v2, v3], pk_indices: [0] }
- sql: |
    create table t(v1 int, v2 int);
    select v1 from t group by v2;
  planner_error: 'Invalid input syntax: column must appear in the GROUP BY clause or be used in an aggregate function'
- sql: |
    create table t(v1 int, v2 int, v3 int);
    select v3, min(v1) * avg(v1+v2) from t group by v3;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [$0, ($1 * ($2 / $3))], expr_alias: [v3,  ] }
        BatchHashAgg { group_keys: [$0], aggs: [min($1), sum($2), count($2)] }
          BatchExchange { order: [], dist: HashShard([0]) }
            BatchProject { exprs: [$2, $0, ($0 + $1)], expr_alias: [ ,  ,  ] }
              BatchScan { table: t, columns: [v1, v2, v3] }
  stream_plan: |
    StreamMaterialize { table_id: 0, column_order: [$0 ASC], column_id: [#0, #1], pk_indices: [0] }
      StreamProject { exprs: [$0, ($1 * ($2 / $3))], expr_alias: [v3,  ] }
        StreamExchange { dist: Single }
          StreamHashAgg { group_keys: [$0], aggs: [min($1), sum($2), count($2)] }
            StreamProject { exprs: [$2, $0, ($0 + $1)], expr_alias: [ ,  ,  ] }
              StreamExchange { dist: HashShard([0]) }
                StreamTableScan { table: t, columns: [v1, v2, v3], pk_indices: [0] }
