# This file is automatically generated. See `src/frontend/test_runner/README.md` for more information.
- id: create_tables
  sql: |
    create table A      (k1 int, k2 int, k3 int, v int);
    create index Ak1   on A(k1) include(k1,k2,k3,v);
    create index Ak1k2 on A(k1,k2) include(k1,k2,k3,v);
    create table B      (k1 int, k2 int, k3 int, v int);
    create index Bk1   on B(k1) include(k1,k2,k3,v);
- id: A_join_B_onk1
  before:
  - create_tables
  sql: select A.v, B.v as Bv from A join B using(k1);
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchHashJoin { type: Inner, predicate: a.k1 = b.k1, output: [a.v, b.v] }
        BatchExchange { order: [], dist: HashShard(a.k1) }
          BatchScan { table: a, columns: [a.k1, a.v], distribution: SomeShard }
        BatchExchange { order: [], dist: HashShard(b.k1) }
          BatchScan { table: b, columns: [b.k1, b.v], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [v, bv, ak1.a._row_id(hidden), bk1.b._row_id(hidden)], pk_columns: [ak1.a._row_id, bk1.b._row_id] }
      StreamExchange { dist: HashShard(ak1.a._row_id, bk1.b._row_id) }
        StreamDeltaJoin { type: Inner, predicate: ak1.k1 = bk1.k1, output: [ak1.v, bk1.v, ak1.a._row_id, bk1.b._row_id] }
          StreamIndexScan { index: ak1, columns: [ak1.k1, ak1.v, ak1.a._row_id], pk: [ak1.a._row_id], distribution: HashShard(ak1.k1) }
          StreamIndexScan { index: bk1, columns: [bk1.k1, bk1.v, bk1.b._row_id], pk: [bk1.b._row_id], distribution: HashShard(bk1.k1) }
- id: Ak1_join_B_onk1
  before:
  - create_tables
  sql: select A.v, B.v as Bv from Ak1 as A join B using(k1)
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchHashJoin { type: Inner, predicate: ak1.k1 = b.k1, output: [ak1.v, b.v] }
        BatchExchange { order: [], dist: HashShard(ak1.k1) }
          BatchScan { table: ak1, columns: [ak1.k1, ak1.v], distribution: UpstreamHashShard(ak1.k1) }
        BatchExchange { order: [], dist: HashShard(b.k1) }
          BatchScan { table: b, columns: [b.k1, b.v], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [v, bv, ak1.a._row_id(hidden), b._row_id(hidden)], pk_columns: [ak1.a._row_id, b._row_id] }
      StreamExchange { dist: HashShard(ak1.a._row_id, b._row_id) }
        StreamHashJoin { type: Inner, predicate: ak1.k1 = b.k1, output: [ak1.v, b.v, ak1.a._row_id, b._row_id] }
          StreamExchange { dist: HashShard(ak1.k1) }
            StreamTableScan { table: ak1, columns: [ak1.k1, ak1.v, ak1.a._row_id], pk: [ak1.a._row_id], distribution: UpstreamHashShard(ak1.k1) }
          StreamExchange { dist: HashShard(b.k1) }
            StreamTableScan { table: b, columns: [b.k1, b.v, b._row_id], pk: [b._row_id], distribution: UpstreamHashShard(b._row_id) }
- id: A_join_Bk1_onk1
  before:
  - create_tables
  sql: select A.v, B.v as Bv from Ak1 as A join Bk1 as B using(k1)
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchHashJoin { type: Inner, predicate: ak1.k1 = bk1.k1, output: [ak1.v, bk1.v] }
        BatchExchange { order: [], dist: HashShard(ak1.k1) }
          BatchScan { table: ak1, columns: [ak1.k1, ak1.v], distribution: UpstreamHashShard(ak1.k1) }
        BatchExchange { order: [], dist: HashShard(bk1.k1) }
          BatchScan { table: bk1, columns: [bk1.k1, bk1.v], distribution: UpstreamHashShard(bk1.k1) }
  stream_plan: |
    StreamMaterialize { columns: [v, bv, ak1.a._row_id(hidden), bk1.b._row_id(hidden)], pk_columns: [ak1.a._row_id, bk1.b._row_id] }
      StreamExchange { dist: HashShard(ak1.a._row_id, bk1.b._row_id) }
        StreamHashJoin { type: Inner, predicate: ak1.k1 = bk1.k1, output: [ak1.v, bk1.v, ak1.a._row_id, bk1.b._row_id] }
          StreamExchange { dist: HashShard(ak1.k1) }
            StreamTableScan { table: ak1, columns: [ak1.k1, ak1.v, ak1.a._row_id], pk: [ak1.a._row_id], distribution: UpstreamHashShard(ak1.k1) }
          StreamExchange { dist: HashShard(bk1.k1) }
            StreamTableScan { table: bk1, columns: [bk1.k1, bk1.v, bk1.b._row_id], pk: [bk1.b._row_id], distribution: UpstreamHashShard(bk1.k1) }
- id: Ak1_join_Bk1_onk1
  before:
  - create_tables
  sql: select A.v, B.v as Bv from Ak1 as A join Bk1 as B using(k1)
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchHashJoin { type: Inner, predicate: ak1.k1 = bk1.k1, output: [ak1.v, bk1.v] }
        BatchExchange { order: [], dist: HashShard(ak1.k1) }
          BatchScan { table: ak1, columns: [ak1.k1, ak1.v], distribution: UpstreamHashShard(ak1.k1) }
        BatchExchange { order: [], dist: HashShard(bk1.k1) }
          BatchScan { table: bk1, columns: [bk1.k1, bk1.v], distribution: UpstreamHashShard(bk1.k1) }
  stream_plan: |
    StreamMaterialize { columns: [v, bv, ak1.a._row_id(hidden), bk1.b._row_id(hidden)], pk_columns: [ak1.a._row_id, bk1.b._row_id] }
      StreamExchange { dist: HashShard(ak1.a._row_id, bk1.b._row_id) }
        StreamHashJoin { type: Inner, predicate: ak1.k1 = bk1.k1, output: [ak1.v, bk1.v, ak1.a._row_id, bk1.b._row_id] }
          StreamExchange { dist: HashShard(ak1.k1) }
            StreamTableScan { table: ak1, columns: [ak1.k1, ak1.v, ak1.a._row_id], pk: [ak1.a._row_id], distribution: UpstreamHashShard(ak1.k1) }
          StreamExchange { dist: HashShard(bk1.k1) }
            StreamTableScan { table: bk1, columns: [bk1.k1, bk1.v, bk1.b._row_id], pk: [bk1.b._row_id], distribution: UpstreamHashShard(bk1.k1) }
- id: aggk1_from_A
  before:
  - create_tables
  sql: |
    select max(v) as max_v
    from A
    group by k1;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [max(a.v)] }
        BatchHashAgg { group_key: [a.k1], aggs: [max(a.v)] }
          BatchExchange { order: [], dist: HashShard(a.k1) }
            BatchScan { table: a, columns: [a.k1, a.v], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [max_v, a.k1(hidden)], pk_columns: [a.k1] }
      StreamProject { exprs: [max(max(a.v)), a.k1] }
        StreamHashAgg { group_key: [a.k1], aggs: [sum(count), max(max(a.v))] }
          StreamExchange { dist: HashShard(a.k1) }
            StreamHashAgg { group_key: [a.k1, Vnode(a._row_id)], aggs: [count, max(a.v)] }
              StreamProject { exprs: [a.k1, a.v, a._row_id, Vnode(a._row_id)] }
                StreamTableScan { table: a, columns: [a.k1, a.v, a._row_id], pk: [a._row_id], distribution: UpstreamHashShard(a._row_id) }
- id: aggk1_from_Ak1
  before:
  - create_tables
  sql: |
    select max(v) as max_v
    from Ak1 as A
    group by k1;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [max(ak1.v)] }
        BatchHashAgg { group_key: [ak1.k1], aggs: [max(ak1.v)] }
          BatchScan { table: ak1, columns: [ak1.k1, ak1.v], distribution: UpstreamHashShard(ak1.k1) }
  stream_plan: |
    StreamMaterialize { columns: [max_v, ak1.k1(hidden)], pk_columns: [ak1.k1] }
      StreamProject { exprs: [max(max(ak1.v)), ak1.k1] }
        StreamHashAgg { group_key: [ak1.k1], aggs: [sum(count), max(max(ak1.v))] }
          StreamHashAgg { group_key: [ak1.k1, Vnode(ak1.k1)], aggs: [count, max(ak1.v)] }
            StreamProject { exprs: [ak1.k1, ak1.v, ak1.a._row_id, Vnode(ak1.k1)] }
              StreamTableScan { table: ak1, columns: [ak1.k1, ak1.v, ak1.a._row_id], pk: [ak1.a._row_id], distribution: UpstreamHashShard(ak1.k1) }
- id: aggk1_from_Ak1k2
  before:
  - create_tables
  sql: |
    select max(v) as max_v
    from Ak1k2 as A
    group by k1;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [max(ak1k2.v)] }
        BatchHashAgg { group_key: [ak1k2.k1], aggs: [max(ak1k2.v)] }
          BatchExchange { order: [], dist: HashShard(ak1k2.k1) }
            BatchScan { table: ak1k2, columns: [ak1k2.k1, ak1k2.v], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [max_v, ak1k2.k1(hidden)], pk_columns: [ak1k2.k1] }
      StreamProject { exprs: [max(max(ak1k2.v)), ak1k2.k1] }
        StreamHashAgg { group_key: [ak1k2.k1], aggs: [sum(count), max(max(ak1k2.v))] }
          StreamExchange { dist: HashShard(ak1k2.k1) }
            StreamHashAgg { group_key: [ak1k2.k1, Vnode(ak1k2.k1, ak1k2.k2)], aggs: [count, max(ak1k2.v)] }
              StreamProject { exprs: [ak1k2.k1, ak1k2.v, ak1k2.k2, ak1k2.a._row_id, Vnode(ak1k2.k1, ak1k2.k2)] }
                StreamTableScan { table: ak1k2, columns: [ak1k2.k1, ak1k2.v, ak1k2.k2, ak1k2.a._row_id], pk: [ak1k2.a._row_id], distribution: UpstreamHashShard(ak1k2.k1, ak1k2.k2) }
- id: aggk2_from_Ak1k2
  before:
  - create_tables
  sql: |
    select max(v) as max_v
    from Ak1k2 as A
    group by k2;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [max(ak1k2.v)] }
        BatchHashAgg { group_key: [ak1k2.k2], aggs: [max(ak1k2.v)] }
          BatchExchange { order: [], dist: HashShard(ak1k2.k2) }
            BatchScan { table: ak1k2, columns: [ak1k2.k2, ak1k2.v], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [max_v, ak1k2.k2(hidden)], pk_columns: [ak1k2.k2] }
      StreamProject { exprs: [max(max(ak1k2.v)), ak1k2.k2] }
        StreamHashAgg { group_key: [ak1k2.k2], aggs: [sum(count), max(max(ak1k2.v))] }
          StreamExchange { dist: HashShard(ak1k2.k2) }
            StreamHashAgg { group_key: [ak1k2.k2, Vnode(ak1k2.k1, ak1k2.k2)], aggs: [count, max(ak1k2.v)] }
              StreamProject { exprs: [ak1k2.k2, ak1k2.v, ak1k2.k1, ak1k2.a._row_id, Vnode(ak1k2.k1, ak1k2.k2)] }
                StreamTableScan { table: ak1k2, columns: [ak1k2.k2, ak1k2.v, ak1k2.k1, ak1k2.a._row_id], pk: [ak1k2.a._row_id], distribution: UpstreamHashShard(ak1k2.k1, ak1k2.k2) }
- id: aggk1k2_from_Ak1k2
  before:
  - create_tables
  sql: |
    select sum(v) as sum_v
    from Ak1k2 as A
    group by k1, k2;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [sum(ak1k2.v)] }
        BatchHashAgg { group_key: [ak1k2.k1, ak1k2.k2], aggs: [sum(ak1k2.v)] }
          BatchScan { table: ak1k2, columns: [ak1k2.k1, ak1k2.k2, ak1k2.v], distribution: UpstreamHashShard(ak1k2.k1, ak1k2.k2) }
  stream_plan: |
    StreamMaterialize { columns: [sum_v, ak1k2.k1(hidden), ak1k2.k2(hidden)], pk_columns: [ak1k2.k1, ak1k2.k2] }
      StreamProject { exprs: [sum(sum(ak1k2.v)), ak1k2.k1, ak1k2.k2] }
        StreamHashAgg { group_key: [ak1k2.k1, ak1k2.k2], aggs: [sum(count), sum(sum(ak1k2.v))] }
          StreamHashAgg { group_key: [ak1k2.k1, ak1k2.k2, Vnode(ak1k2.k1, ak1k2.k2)], aggs: [count, sum(ak1k2.v)] }
            StreamProject { exprs: [ak1k2.k1, ak1k2.k2, ak1k2.v, ak1k2.a._row_id, Vnode(ak1k2.k1, ak1k2.k2)] }
              StreamTableScan { table: ak1k2, columns: [ak1k2.k1, ak1k2.k2, ak1k2.v, ak1k2.a._row_id], pk: [ak1k2.a._row_id], distribution: UpstreamHashShard(ak1k2.k1, ak1k2.k2) }
- id: aggk1_from_aggk1
  before:
  - create_tables
  sql: |
    select
      max(num) as max_num
    from (
      select
        count(*) as num, k1
      from A
      group by k1
    )
    group by k1;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [max(count)] }
        BatchHashAgg { group_key: [a.k1], aggs: [max(count)] }
          BatchHashAgg { group_key: [a.k1], aggs: [count] }
            BatchExchange { order: [], dist: HashShard(a.k1) }
              BatchScan { table: a, columns: [a.k1], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [max_num, a.k1(hidden)], pk_columns: [a.k1] }
      StreamProject { exprs: [max(max(sum(count))), a.k1] }
        StreamHashAgg { group_key: [a.k1], aggs: [sum(count), max(max(sum(count)))] }
          StreamHashAgg { group_key: [a.k1, Vnode(a.k1)], aggs: [count, max(sum(count))] }
            StreamProject { exprs: [a.k1, sum(count), Vnode(a.k1)] }
              StreamProject { exprs: [a.k1, sum(count)] }
                StreamHashAgg { group_key: [a.k1], aggs: [sum(count), sum(count)] }
                  StreamExchange { dist: HashShard(a.k1) }
                    StreamHashAgg { group_key: [a.k1, Vnode(a._row_id)], aggs: [count, count] }
                      StreamProject { exprs: [a.k1, a._row_id, Vnode(a._row_id)] }
                        StreamTableScan { table: a, columns: [a.k1, a._row_id], pk: [a._row_id], distribution: UpstreamHashShard(a._row_id) }
- id: aggk1_from_aggk1k2
  before:
  - create_tables
  sql: |
    select
      max(num) as max_num
    from (
      select
        count(*) as num, k1
      from A
      group by k1, k2
    )
    group by k1;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [max(count)] }
        BatchHashAgg { group_key: [a.k1], aggs: [max(count)] }
          BatchExchange { order: [], dist: HashShard(a.k1) }
            BatchProject { exprs: [a.k1, count] }
              BatchHashAgg { group_key: [a.k1, a.k2], aggs: [count] }
                BatchExchange { order: [], dist: HashShard(a.k1, a.k2) }
                  BatchScan { table: a, columns: [a.k1, a.k2], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [max_num, a.k1(hidden)], pk_columns: [a.k1] }
      StreamProject { exprs: [max(max(sum(count))), a.k1] }
        StreamHashAgg { group_key: [a.k1], aggs: [sum(count), max(max(sum(count)))] }
          StreamExchange { dist: HashShard(a.k1) }
            StreamHashAgg { group_key: [a.k1, Vnode(a.k1, a.k2)], aggs: [count, max(sum(count))] }
              StreamProject { exprs: [a.k1, sum(count), a.k2, Vnode(a.k1, a.k2)] }
                StreamProject { exprs: [a.k1, sum(count), a.k2] }
                  StreamHashAgg { group_key: [a.k1, a.k2], aggs: [sum(count), sum(count)] }
                    StreamExchange { dist: HashShard(a.k1, a.k2) }
                      StreamHashAgg { group_key: [a.k1, a.k2, Vnode(a._row_id)], aggs: [count, count] }
                        StreamProject { exprs: [a.k1, a.k2, a._row_id, Vnode(a._row_id)] }
                          StreamTableScan { table: a, columns: [a.k1, a.k2, a._row_id], pk: [a._row_id], distribution: UpstreamHashShard(a._row_id) }
- id: aggk2_from_aggk1k2
  before:
  - create_tables
  sql: |
    select
      max(num) as max_num
    from (
      select
        count(*) as num, k2
      from A
      group by k1, k2
    )
    group by k2;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [max(count)] }
        BatchHashAgg { group_key: [a.k2], aggs: [max(count)] }
          BatchExchange { order: [], dist: HashShard(a.k2) }
            BatchProject { exprs: [a.k2, count] }
              BatchHashAgg { group_key: [a.k1, a.k2], aggs: [count] }
                BatchExchange { order: [], dist: HashShard(a.k1, a.k2) }
                  BatchScan { table: a, columns: [a.k1, a.k2], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [max_num, a.k2(hidden)], pk_columns: [a.k2] }
      StreamProject { exprs: [max(max(sum(count))), a.k2] }
        StreamHashAgg { group_key: [a.k2], aggs: [sum(count), max(max(sum(count)))] }
          StreamExchange { dist: HashShard(a.k2) }
            StreamHashAgg { group_key: [a.k2, Vnode(a.k1, a.k2)], aggs: [count, max(sum(count))] }
              StreamProject { exprs: [a.k2, sum(count), a.k1, Vnode(a.k1, a.k2)] }
                StreamProject { exprs: [a.k2, sum(count), a.k1] }
                  StreamHashAgg { group_key: [a.k1, a.k2], aggs: [sum(count), sum(count)] }
                    StreamExchange { dist: HashShard(a.k1, a.k2) }
                      StreamHashAgg { group_key: [a.k1, a.k2, Vnode(a._row_id)], aggs: [count, count] }
                        StreamProject { exprs: [a.k1, a.k2, a._row_id, Vnode(a._row_id)] }
                          StreamTableScan { table: a, columns: [a.k1, a.k2, a._row_id], pk: [a._row_id], distribution: UpstreamHashShard(a._row_id) }
- id: aggk1k2_from_aggk1k2
  before:
  - create_tables
  sql: |
    select
      max(num) as max_num
    from (
      select
        count(*) as num, k2
      from A
      group by k1, k2
    )
    group by k2;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [max(count)] }
        BatchHashAgg { group_key: [a.k2], aggs: [max(count)] }
          BatchExchange { order: [], dist: HashShard(a.k2) }
            BatchProject { exprs: [a.k2, count] }
              BatchHashAgg { group_key: [a.k1, a.k2], aggs: [count] }
                BatchExchange { order: [], dist: HashShard(a.k1, a.k2) }
                  BatchScan { table: a, columns: [a.k1, a.k2], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [max_num, a.k2(hidden)], pk_columns: [a.k2] }
      StreamProject { exprs: [max(max(sum(count))), a.k2] }
        StreamHashAgg { group_key: [a.k2], aggs: [sum(count), max(max(sum(count)))] }
          StreamExchange { dist: HashShard(a.k2) }
            StreamHashAgg { group_key: [a.k2, Vnode(a.k1, a.k2)], aggs: [count, max(sum(count))] }
              StreamProject { exprs: [a.k2, sum(count), a.k1, Vnode(a.k1, a.k2)] }
                StreamProject { exprs: [a.k2, sum(count), a.k1] }
                  StreamHashAgg { group_key: [a.k1, a.k2], aggs: [sum(count), sum(count)] }
                    StreamExchange { dist: HashShard(a.k1, a.k2) }
                      StreamHashAgg { group_key: [a.k1, a.k2, Vnode(a._row_id)], aggs: [count, count] }
                        StreamProject { exprs: [a.k1, a.k2, a._row_id, Vnode(a._row_id)] }
                          StreamTableScan { table: a, columns: [a.k1, a.k2, a._row_id], pk: [a._row_id], distribution: UpstreamHashShard(a._row_id) }
- id: Ak1_join_Bk1_onk1
  before:
  - create_tables
  sql: select A.v, B.v as Bv from Ak1 as A join Bk1 as B using(k1)
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchHashJoin { type: Inner, predicate: ak1.k1 = bk1.k1, output: [ak1.v, bk1.v] }
        BatchExchange { order: [], dist: HashShard(ak1.k1) }
          BatchScan { table: ak1, columns: [ak1.k1, ak1.v], distribution: UpstreamHashShard(ak1.k1) }
        BatchExchange { order: [], dist: HashShard(bk1.k1) }
          BatchScan { table: bk1, columns: [bk1.k1, bk1.v], distribution: UpstreamHashShard(bk1.k1) }
  stream_plan: |
    StreamMaterialize { columns: [v, bv, ak1.a._row_id(hidden), bk1.b._row_id(hidden)], pk_columns: [ak1.a._row_id, bk1.b._row_id] }
      StreamExchange { dist: HashShard(ak1.a._row_id, bk1.b._row_id) }
        StreamHashJoin { type: Inner, predicate: ak1.k1 = bk1.k1, output: [ak1.v, bk1.v, ak1.a._row_id, bk1.b._row_id] }
          StreamExchange { dist: HashShard(ak1.k1) }
            StreamTableScan { table: ak1, columns: [ak1.k1, ak1.v, ak1.a._row_id], pk: [ak1.a._row_id], distribution: UpstreamHashShard(ak1.k1) }
          StreamExchange { dist: HashShard(bk1.k1) }
            StreamTableScan { table: bk1, columns: [bk1.k1, bk1.v, bk1.b._row_id], pk: [bk1.b._row_id], distribution: UpstreamHashShard(bk1.k1) }
