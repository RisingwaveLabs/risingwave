- sql: |
    create materialized view t as select country from s;
    select * from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchScan { table: t, columns: [country] }
  stream_plan: |
    StreamMaterialize { columns: [country, _row_id#0(hidden)], pk_columns: [_row_id#0] }
      StreamExchange { dist: HashShard([1]) }
        StreamTableScan { table: t, columns: [country, _row_id#0], pk_indices: [1] }
  create_source:
    row_format: protobuf
    name: s
    file: |
        syntax = "proto3";
        package test;
        message TestRecord {
          int32 id = 1;
          Country country = 3;
          int64 zipcode = 4;
          float rate = 5;
        }
        message Country {
          string address = 1;
          City city = 2;
          string zipcode = 3;
        }
        message City {
          string address = 1;
          string zipcode = 2;
        }
- sql: |
    create materialized view t as select * from s;
    select (t).country.city,(t.country).address,(country).city.address from t;
  create_source:
    row_format: protobuf
    name: s
    file: |
      syntax = "proto3";
      package test;
      message TestRecord {
        int32 id = 1;
        Country country = 3;
        int64 zipcode = 4;
        float rate = 5;
      }
      message Country {
        string address = 1;
        City city = 2;
        string zipcode = 3;
      }
      message City {
        string address = 1;
        string zipcode = 2;
      }
  logical_plan: |
    LogicalProject { exprs: [Field($1, 1:Struct { fields: [Varchar, Varchar] }), Field($1, 0:Varchar), Field($1, 1:Struct { fields: [Varchar, Varchar] }, 0:Varchar)], expr_alias: [city, address, address] }
      LogicalScan { table: t, columns: [id, country, zipcode, rate, _row_id#0] }
- sql: |
    create materialized view t as select * from s;
    select (t).country1.city.*,(t.country2).*,(country3).city.* from t;
  create_source:
    row_format: protobuf
    name: s
    file: |
      syntax = "proto3";
      package test;
      message TestRecord {
        int32 id = 1;
        Country country1 = 3;
        Country country2 = 3;
        Country country3 = 3;
        int64 zipcode = 4;
        float rate = 5;
      }
      message Country {
        string address = 1;
        City city = 2;
        string zipcode = 3;
      }
      message City {
        string address = 1;
        string zipcode = 2;
      }
  logical_plan: |
    LogicalProject { exprs: [Field($1, 1:Struct { fields: [Varchar, Varchar] }, 0:Varchar), Field($1, 1:Struct { fields: [Varchar, Varchar] }, 1:Varchar), Field($2, 0:Varchar), Field($2, 1:Struct { fields: [Varchar, Varchar] }), Field($2, 2:Varchar), Field($3, 1:Struct { fields: [Varchar, Varchar] }, 0:Varchar), Field($3, 1:Struct { fields: [Varchar, Varchar] }, 1:Varchar)], expr_alias: [address, zipcode, address, city, zipcode, address, zipcode] }
      LogicalScan { table: t, columns: [id, country1, country2, country3, zipcode, rate, _row_id#0] }
- sql: |
    create materialized view t as select * from s;
    select (c).zipcode from (select (t).country.city as c from t);
  create_source:
    row_format: protobuf
    name: s
    file: |
      syntax = "proto3";
      package test;
      message TestRecord {
        int32 id = 1;
        Country country = 3;
        int64 zipcode = 4;
        float rate = 5;
      }
      message Country {
        string address = 1;
        City city = 2;
        string zipcode = 3;
      }
      message City {
        string address = 1;
        string zipcode = 2;
      }
  logical_plan: |
    LogicalProject { exprs: [Field($0, 1:Varchar)], expr_alias: [zipcode] }
      LogicalProject { exprs: [Field($1, 1:Struct { fields: [Varchar, Varchar] })], expr_alias: [c] }
        LogicalScan { table: t, columns: [id, country, zipcode, rate, _row_id#0] }
- sql: |
    create materialized view t as select * from s;
    select (c).zipcode from (select min((t).country.city) as c from t);
  create_source:
    row_format: protobuf
    name: s
    file: |
      syntax = "proto3";
      package test;
      message TestRecord {
        int32 id = 1;
        Country country = 3;
        int64 zipcode = 4;
        float rate = 5;
      }
      message Country {
        string address = 1;
        City city = 2;
        string zipcode = 3;
      }
      message City {
        string address = 1;
        string zipcode = 2;
      }
  logical_plan: |
    LogicalProject { exprs: [Field($0, 1:Varchar)], expr_alias: [zipcode] }
      LogicalProject { exprs: [$0], expr_alias: [c] }
        LogicalAgg { group_keys: [], agg_calls: [min($0)] }
          LogicalProject { exprs: [Field($1, 1:Struct { fields: [Varchar, Varchar] })], expr_alias: [ ] }
            LogicalScan { table: t, columns: [id, country, zipcode, rate, _row_id#0] }
- sql: |
    create materialized view t as select * from s;
    select * from (select (country).city as c from t) as vv join t on (c).zipcode=(t.country).zipcode;
  create_source:
    row_format: protobuf
    name: s
    file: |
      syntax = "proto3";
      package test;
      message TestRecord {
        int32 id = 1;
        Country country = 3;
        int64 zipcode = 4;
        float rate = 5;
      }
      message Country {
        string address = 1;
        City city = 2;
        string zipcode = 3;
      }
      message City {
        string address = 1;
        string zipcode = 2;
      }
  logical_plan: |
    LogicalProject { exprs: [$0, $1, $2, $3, $4], expr_alias: [c, id, country, zipcode, rate] }
      LogicalJoin { type: Inner, on: (Field($0, 1:Varchar) = Field($2, 2:Varchar)) }
        LogicalProject { exprs: [Field($1, 1:Struct { fields: [Varchar, Varchar] })], expr_alias: [c] }
          LogicalScan { table: t, columns: [id, country, zipcode, rate, _row_id#0] }
        LogicalScan { table: t, columns: [id, country, zipcode, rate, _row_id#0] }
- sql: |
    create materialized view t as select * from s;
    select min((t.country).city.address) + max((t.country).city.address) * count(zipcode) from t;
  create_source:
    row_format: protobuf
    name: s
    file: |
      syntax = "proto3";
      package test;
      message TestRecord {
        int32 id = 1;
        Country country = 3;
        int64 zipcode = 4;
        float rate = 5;
      }
      message Country {
        string address = 1;
        City city = 2;
        string zipcode = 3;
      }
      message City {
        int64 address = 1;
        string zipcode = 2;
      }
  logical_plan: |
    LogicalProject { exprs: [($0 + ($1 * $2))], expr_alias: [ ] }
      LogicalAgg { group_keys: [], agg_calls: [min($0), max($0), count($1)] }
        LogicalProject { exprs: [Field($1, 1:Struct { fields: [Int64, Varchar] }, 0:Int64), $2], expr_alias: [ ,  ] }
          LogicalScan { table: t, columns: [id, country, zipcode, rate, _row_id#0] }
- sql: |
    create materialized view t as select * from s;
    select count(1), count((country).city.zipcode) from t where (country).city.address>1;
  create_source:
    row_format: protobuf
    name: s
    file: |
      syntax = "proto3";
      package test;
      message TestRecord {
        int32 id = 1;
        Country country = 3;
        int64 zipcode = 4;
        float rate = 5;
      }
      message Country {
        string address = 1;
        City city = 2;
        string zipcode = 3;
      }
      message City {
        int64 address = 1;
        string zipcode = 2;
      }
  logical_plan: |
    LogicalProject { exprs: [$0, $1], expr_alias: [ ,  ] }
      LogicalAgg { group_keys: [], agg_calls: [count($0), count($1)] }
        LogicalProject { exprs: [1:Int32, Field($1, 1:Struct { fields: [Int64, Varchar] }, 1:Varchar)], expr_alias: [ ,  ] }
          LogicalFilter { predicate: (Field($1, 1:Struct { fields: [Int64, Varchar] }, 0:Int64) > 1:Int32) }
            LogicalScan { table: t, columns: [id, country, zipcode, rate, _row_id#0] }