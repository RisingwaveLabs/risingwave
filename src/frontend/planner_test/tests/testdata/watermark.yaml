# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- name: watermark on source
  sql: |
    create source t (v1 timestamp with time zone, watermark for v1 as v1 - INTERVAL '1' SECOND) with (connector = 'kinesis') ROW FORMAT JSON;
    select t.v1 - INTERVAL '2' SECOND as v1 from t;
  logical_plan: |
    LogicalProject { exprs: [(v1 - '00:00:02':Interval) as $expr1] }
    └─LogicalSource { source: t, columns: [v1, _row_id], time_range: [(Unbounded, Unbounded)] }
  stream_plan: |
    StreamMaterialize { columns: [v1, _row_id(hidden)], pk_columns: [_row_id], pk_conflict: "no check" }
    └─StreamExchange { dist: HashShard(_row_id) }
      └─StreamProject { exprs: [(AtTimeZone((AtTimeZone(v1, 'UTC':Varchar) - '00:00:00':Interval), 'UTC':Varchar) - '00:00:02':Interval) as $expr1, _row_id], output_watermarks: [$expr1] }
        └─StreamRowIdGen { row_id_index: 1 }
          └─StreamWatermarkFilter { watermark_descs: [idx: 0, expr: (v1 - '00:00:01':Interval)] }
            └─StreamSource { source: "t", columns: ["v1", "_row_id"] }
- name: watermark on append only table with source
  sql: |
    explain create table t (v1 timestamp with time zone, watermark for v1 as v1 - INTERVAL '1' SECOND) append only with (connector = 'kafka', kafka.topic = 'kafka_3_partition_topic', kafka.brokers = '127.0.0.1:1234', kafka.scan.startup.mode='earliest') ROW FORMAT JSON;
  explain_output: |
    StreamMaterialize { columns: [v1, _row_id(hidden)], pk_columns: [_row_id], pk_conflict: "no check" }
    └─StreamExchange { dist: HashShard(_row_id) }
      └─StreamRowIdGen { row_id_index: 1 }
        └─StreamWatermarkFilter { watermark_descs: [idx: 0, expr: (v1 - '00:00:01':Interval)] }
          └─StreamDml { columns: [v1, _row_id] }
            └─StreamSource { source: "t", columns: ["v1", "_row_id"] }
- name: watermark on append only table without source
  sql: |
    explain create table t (v1 timestamp with time zone, watermark for v1 as v1 - INTERVAL '1' SECOND) append only;
  explain_output: |
    StreamMaterialize { columns: [v1, _row_id(hidden)], pk_columns: [_row_id], pk_conflict: "no check" }
    └─StreamExchange { dist: HashShard(_row_id) }
      └─StreamRowIdGen { row_id_index: 1 }
        └─StreamWatermarkFilter { watermark_descs: [idx: 0, expr: (v1 - '00:00:01':Interval)] }
          └─StreamDml { columns: [v1, _row_id] }
            └─StreamSource
- name: hash agg
  sql: |
    create table t (ts timestamp with time zone, v1 int, v2 int, watermark for ts as ts - INTERVAL '1' SECOND) append only;
    select count(v2) from t group by ts, v1;
  stream_plan: |
    StreamMaterialize { columns: [count, t.ts(hidden), t.v1(hidden)], pk_columns: [t.ts, t.v1], pk_conflict: "no check" }
    └─StreamProject { exprs: [count(t.v2), t.ts, t.v1], output_watermarks: [t.ts] }
      └─StreamAppendOnlyHashAgg { group_key: [t.ts, t.v1], aggs: [count(t.v2), count], output_watermarks: [t.ts] }
        └─StreamExchange { dist: HashShard(t.ts, t.v1) }
          └─StreamTableScan { table: t, columns: [t.ts, t.v1, t.v2, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
