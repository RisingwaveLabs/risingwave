# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- id: create_tables
  sql: |
    create table t1 (v1 int);
    create table t2 (v2 int);
- name: With Simple Agg on inner side
  before:
  - create_tables
  sql: |
    with max_v2 as (select max(v2) max from t2) select v1 from t1, max_v2 where v1 > max;
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: (t1.v1 > max(t2.v2)), output: [t1.v1] }
    ├─LogicalScan { table: t1, columns: [t1.v1] }
    └─LogicalAgg { aggs: [max(t2.v2)] }
      └─LogicalScan { table: t2, columns: [t2.v2] }
  stream_plan: |
    StreamMaterialize { columns: [v1, t1._row_id(hidden)], pk_columns: [t1._row_id] }
    └─StreamDynamicFilter { predicate: (t1.v1 > max(max(t2.v2))), output: [t1.v1, t1._row_id] }
      ├─StreamTableScan { table: t1, columns: [t1.v1, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
      └─StreamExchange { dist: Broadcast }
        └─StreamProject { exprs: [max(max(t2.v2))] }
          └─StreamGlobalSimpleAgg { aggs: [count, max(max(t2.v2))] }
            └─StreamExchange { dist: Single }
              └─StreamHashAgg { group_key: [Vnode(t2._row_id)], aggs: [count, max(t2.v2)] }
                └─StreamProject { exprs: [t2.v2, t2._row_id, Vnode(t2._row_id)] }
                  └─StreamTableScan { table: t2, columns: [t2.v2, t2._row_id], pk: [t2._row_id], dist: UpstreamHashShard(t2._row_id) }
- name: |
    With Top-1 on inner side
    TODO: currently not possible due to https://github.com/risingwavelabs/risingwave/issues/5764
  before:
  - create_tables
  sql: |
    with max_v2 as (select v2 max from t2 order by v2 desc limit 1) select v1 from t1, max_v2 where v1 > max;
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: (t1.v1 > t2.v2), output: [t1.v1] }
    ├─LogicalScan { table: t1, columns: [t1.v1] }
    └─LogicalProject { exprs: [t2.v2] }
      └─LogicalTopN { order: "[t2.v2 DESC]", limit: 1, offset: 0 }
        └─LogicalProject { exprs: [t2.v2, t2.v2] }
          └─LogicalScan { table: t2, columns: [t2.v2] }
  stream_error: |-
    Not supported: streaming nested-loop join
    HINT: The non-equal join in the query requires a nested-loop join executor, which could be very expensive to run. Consider rewriting the query to use dynamic filter as a substitute if possible.
    See also: https://github.com/risingwavelabs/rfcs/blob/main/rfcs/0033-dynamic-filter.md
- name: |
    Output indices of Dynamic Filter
    TODO: currently implemented by adding a Project, https://github.com/risingwavelabs/risingwave/issues/3419
  before:
  - create_tables
  sql: |
    with max_v2 as (select max(v2) max from t2) select v1 from t1, max_v2 where v1 + v1 > max;
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: ((t1.v1 + t1.v1) > max(t2.v2)), output: [t1.v1] }
    ├─LogicalProject { exprs: [t1.v1, (t1.v1 + t1.v1)] }
    | └─LogicalScan { table: t1, columns: [t1.v1] }
    └─LogicalAgg { aggs: [max(t2.v2)] }
      └─LogicalScan { table: t2, columns: [t2.v2] }
  stream_plan: |
    StreamMaterialize { columns: [v1, t1._row_id(hidden)], pk_columns: [t1._row_id] }
    └─StreamProject { exprs: [t1.v1, t1._row_id] }
      └─StreamDynamicFilter { predicate: ((t1.v1 + t1.v1) > max(max(t2.v2))), output: [t1.v1, (t1.v1 + t1.v1), t1._row_id] }
        ├─StreamProject { exprs: [t1.v1, (t1.v1 + t1.v1), t1._row_id] }
        | └─StreamTableScan { table: t1, columns: [t1.v1, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
        └─StreamExchange { dist: Broadcast }
          └─StreamProject { exprs: [max(max(t2.v2))] }
            └─StreamGlobalSimpleAgg { aggs: [count, max(max(t2.v2))] }
              └─StreamExchange { dist: Single }
                └─StreamHashAgg { group_key: [Vnode(t2._row_id)], aggs: [count, max(t2.v2)] }
                  └─StreamProject { exprs: [t2.v2, t2._row_id, Vnode(t2._row_id)] }
                    └─StreamTableScan { table: t2, columns: [t2.v2, t2._row_id], pk: [t2._row_id], dist: UpstreamHashShard(t2._row_id) }
- name: Ensure error on multiple rows on inner side
  before:
  - create_tables
  sql: |
    with max_v2 as (select v2 max from t2 order by v2 desc limit 2) select v1 from t1, max_v2 where v1 > max;
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: (t1.v1 > t2.v2), output: [t1.v1] }
    ├─LogicalScan { table: t1, columns: [t1.v1] }
    └─LogicalProject { exprs: [t2.v2] }
      └─LogicalTopN { order: "[t2.v2 DESC]", limit: 2, offset: 0 }
        └─LogicalProject { exprs: [t2.v2, t2.v2] }
          └─LogicalScan { table: t2, columns: [t2.v2] }
  stream_error: |-
    Not supported: streaming nested-loop join
    HINT: The non-equal join in the query requires a nested-loop join executor, which could be very expensive to run. Consider rewriting the query to use dynamic filter as a substitute if possible.
    See also: https://github.com/risingwavelabs/rfcs/blob/main/rfcs/0033-dynamic-filter.md
- name: Ensure error on output columns from inner
  before:
  - create_tables
  sql: |
    with max_v2 as (select max(v2) max from t2) select v1, max from t1, max_v2 where v1 > max;
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: (t1.v1 > max(t2.v2)), output: all }
    ├─LogicalScan { table: t1, columns: [t1.v1] }
    └─LogicalAgg { aggs: [max(t2.v2)] }
      └─LogicalScan { table: t2, columns: [t2.v2] }
  stream_error: |-
    Not supported: streaming nested-loop join
    HINT: The non-equal join in the query requires a nested-loop join executor, which could be very expensive to run. Consider rewriting the query to use dynamic filter as a substitute if possible.
    See also: https://github.com/risingwavelabs/rfcs/blob/main/rfcs/0033-dynamic-filter.md
- name: Use Inner Join for equi condition
  before:
  - create_tables
  sql: |
    with max_v2 as (select max(v2) max from t2) select v1, max from t1, max_v2 where v1 = max;
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: (t1.v1 = max(t2.v2)), output: all }
    ├─LogicalScan { table: t1, columns: [t1.v1] }
    └─LogicalAgg { aggs: [max(t2.v2)] }
      └─LogicalScan { table: t2, columns: [t2.v2] }
  stream_plan: |
    StreamMaterialize { columns: [v1, max, t1._row_id(hidden)], pk_columns: [t1._row_id, v1, max] }
    └─StreamHashJoin { type: Inner, predicate: t1.v1 = max(max(t2.v2)), output: [t1.v1, max(max(t2.v2)), t1._row_id] }
      ├─StreamExchange { dist: HashShard(t1.v1) }
      | └─StreamTableScan { table: t1, columns: [t1.v1, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
      └─StreamExchange { dist: HashShard(max(max(t2.v2))) }
        └─StreamProject { exprs: [max(max(t2.v2))] }
          └─StreamGlobalSimpleAgg { aggs: [count, max(max(t2.v2))] }
            └─StreamExchange { dist: Single }
              └─StreamHashAgg { group_key: [Vnode(t2._row_id)], aggs: [count, max(t2.v2)] }
                └─StreamProject { exprs: [t2.v2, t2._row_id, Vnode(t2._row_id)] }
                  └─StreamTableScan { table: t2, columns: [t2.v2, t2._row_id], pk: [t2._row_id], dist: UpstreamHashShard(t2._row_id) }
- name: Dynamic filter join on unequal types
  sql: |
    create table t1 (v1 int);
    create table t2 (v2 bigint);
    with max_v2 as (select max(v2) max from t2) select v1 from t1, max_v2 where v1 > max;
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: (t1.v1::Int64 > max(t2.v2)), output: [t1.v1] }
    ├─LogicalProject { exprs: [t1.v1, t1.v1::Int64] }
    | └─LogicalScan { table: t1, columns: [t1.v1] }
    └─LogicalAgg { aggs: [max(t2.v2)] }
      └─LogicalScan { table: t2, columns: [t2.v2] }
  stream_plan: |
    StreamMaterialize { columns: [v1, t1._row_id(hidden)], pk_columns: [t1._row_id] }
    └─StreamProject { exprs: [t1.v1, t1._row_id] }
      └─StreamDynamicFilter { predicate: (t1.v1::Int64 > max(max(t2.v2))), output: [t1.v1, t1.v1::Int64, t1._row_id] }
        ├─StreamProject { exprs: [t1.v1, t1.v1::Int64, t1._row_id] }
        | └─StreamTableScan { table: t1, columns: [t1.v1, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
        └─StreamExchange { dist: Broadcast }
          └─StreamProject { exprs: [max(max(t2.v2))] }
            └─StreamGlobalSimpleAgg { aggs: [count, max(max(t2.v2))] }
              └─StreamExchange { dist: Single }
                └─StreamHashAgg { group_key: [Vnode(t2._row_id)], aggs: [count, max(t2.v2)] }
                  └─StreamProject { exprs: [t2.v2, t2._row_id, Vnode(t2._row_id)] }
                    └─StreamTableScan { table: t2, columns: [t2.v2, t2._row_id], pk: [t2._row_id], dist: UpstreamHashShard(t2._row_id) }
- name: Dynamic filter on semi join
  sql: |
    create table t1 (v1 int);
    create table t2 (v2 int);
    with max_v2 as (select max(v2) max from t2) select v1 from t1 where exists (select * from max_v2 where v1 > max);
  stream_plan: |
    StreamMaterialize { columns: [v1, t1._row_id(hidden)], pk_columns: [t1._row_id] }
    └─StreamDynamicFilter { predicate: (t1.v1 > max(max(t2.v2))), output: [t1.v1, t1._row_id] }
      ├─StreamTableScan { table: t1, columns: [t1.v1, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
      └─StreamExchange { dist: Broadcast }
        └─StreamProject { exprs: [max(max(t2.v2))] }
          └─StreamGlobalSimpleAgg { aggs: [count, max(max(t2.v2))] }
            └─StreamExchange { dist: Single }
              └─StreamHashAgg { group_key: [Vnode(t2._row_id)], aggs: [count, max(t2.v2)] }
                └─StreamProject { exprs: [t2.v2, t2._row_id, Vnode(t2._row_id)] }
                  └─StreamTableScan { table: t2, columns: [t2.v2, t2._row_id], pk: [t2._row_id], dist: UpstreamHashShard(t2._row_id) }
- name: Complex expression on RHS of condition will still result in dynamic filter
  before:
  - create_tables
  sql: |
    with max_v2 as (select max(v2) max from t2) select v1 from t1, max_v2 where v1 > 2 * max;
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: (t1.v1 > (2:Int32 * max(t2.v2))), output: [t1.v1] }
    ├─LogicalScan { table: t1, columns: [t1.v1] }
    └─LogicalProject { exprs: [(2:Int32 * max(t2.v2))] }
      └─LogicalAgg { aggs: [max(t2.v2)] }
        └─LogicalScan { table: t2, columns: [t2.v2] }
  stream_plan: |
    StreamMaterialize { columns: [v1, t1._row_id(hidden)], pk_columns: [t1._row_id] }
    └─StreamDynamicFilter { predicate: (t1.v1 > (2:Int32 * max(max(t2.v2)))), output: [t1.v1, t1._row_id] }
      ├─StreamTableScan { table: t1, columns: [t1.v1, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
      └─StreamExchange { dist: Broadcast }
        └─StreamProject { exprs: [(2:Int32 * max(max(t2.v2)))] }
          └─StreamGlobalSimpleAgg { aggs: [count, max(max(t2.v2))] }
            └─StreamExchange { dist: Single }
              └─StreamHashAgg { group_key: [Vnode(t2._row_id)], aggs: [count, max(t2.v2)] }
                └─StreamProject { exprs: [t2.v2, t2._row_id, Vnode(t2._row_id)] }
                  └─StreamTableScan { table: t2, columns: [t2.v2, t2._row_id], pk: [t2._row_id], dist: UpstreamHashShard(t2._row_id) }
- name: Temporal filter works on complex columns on LHS
  sql: |
    create table t1 (ts timestamp with time zone);
    select * from t1 where ts + interval '1 hour' > now();
  stream_plan: |
    StreamMaterialize { columns: [ts, t1._row_id(hidden)], pk_columns: [t1._row_id] }
    └─StreamProject { exprs: [t1.ts, t1._row_id] }
      └─StreamDynamicFilter { predicate: ((t1.ts + '01:00:00':Interval) > now), output: [t1.ts, (t1.ts + '01:00:00':Interval), t1._row_id] }
        ├─StreamProject { exprs: [t1.ts, (t1.ts + '01:00:00':Interval), t1._row_id] }
        | └─StreamTableScan { table: t1, columns: [t1.ts, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
        └─StreamExchange { dist: Broadcast }
          └─StreamNow { output: [now] }
- name: Temporal filter works on complex columns on LHS (part 2)
  sql: |
    create table t1 (ts timestamp with time zone, time_to_live interval);
    select * from t1 where ts + time_to_live * 1.5 > now();
  stream_plan: |
    StreamMaterialize { columns: [ts, time_to_live, t1._row_id(hidden)], pk_columns: [t1._row_id] }
    └─StreamProject { exprs: [t1.ts, t1.time_to_live, t1._row_id] }
      └─StreamDynamicFilter { predicate: ((t1.ts + (t1.time_to_live * 1.5:Decimal)) > now), output: [t1.ts, t1.time_to_live, (t1.ts + (t1.time_to_live * 1.5:Decimal)), t1._row_id] }
        ├─StreamProject { exprs: [t1.ts, t1.time_to_live, (t1.ts + (t1.time_to_live * 1.5:Decimal)), t1._row_id] }
        | └─StreamTableScan { table: t1, columns: [t1.ts, t1.time_to_live, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
        └─StreamExchange { dist: Broadcast }
          └─StreamNow { output: [now] }
- name: Temporal filter works on complex columns on LHS (part 2, flipped)
  sql: |
    create table t1 (ts timestamp with time zone, additional_time_to_live interval);
    select * from t1 where now() - interval '15 minutes' > ts + additional_time_to_live * 1.5;
  stream_plan: |
    StreamMaterialize { columns: [ts, additional_time_to_live, t1._row_id(hidden)], pk_columns: [t1._row_id] }
    └─StreamProject { exprs: [t1.ts, t1.additional_time_to_live, t1._row_id] }
      └─StreamDynamicFilter { predicate: ((t1.ts + (t1.additional_time_to_live * 1.5:Decimal)) < (now - '00:15:00':Interval)), output: [t1.ts, t1.additional_time_to_live, (t1.ts + (t1.additional_time_to_live * 1.5:Decimal)), t1._row_id] }
        ├─StreamProject { exprs: [t1.ts, t1.additional_time_to_live, (t1.ts + (t1.additional_time_to_live * 1.5:Decimal)), t1._row_id] }
        | └─StreamTableScan { table: t1, columns: [t1.ts, t1.additional_time_to_live, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
        └─StreamExchange { dist: Broadcast }
          └─StreamProject { exprs: [(now - '00:15:00':Interval)], watermark_columns: [(now - '00:15:00':Interval)] }
            └─StreamNow { output: [now] }
