# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- id: create_tables
  sql: |
    create table t1 (v1 int);
    create table t2 (v2 int);
- name: Use dynamic filter in streaming, with Simple Agg on inner side
  before:
  - create_tables
  sql: |
    with max_v2 as (select max(v2) max from t2) select v1 from t1, max_v2 where v1 > max;
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: (t1.v1 > max(t2.v2)), output: [t1.v1] }
    ├─LogicalScan { table: t1, columns: [t1.v1] }
    └─LogicalAgg { aggs: [max(t2.v2)] }
      └─LogicalScan { table: t2, columns: [t2.v2] }
  stream_plan: |
    StreamMaterialize { columns: [v1, t1._row_id(hidden)], pk_columns: [t1._row_id] }
    └─StreamDynamicFilter { predicate: (t1.v1 > max(max(t2.v2))), output: [t1.v1, t1._row_id] }
      ├─StreamTableScan { table: t1, columns: [t1.v1, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
      └─StreamExchange { dist: Broadcast }
        └─StreamProject { exprs: [max(max(t2.v2))] }
          └─StreamGlobalSimpleAgg { aggs: [sum(count), max(max(t2.v2))] }
            └─StreamExchange { dist: Single }
              └─StreamHashAgg { group_key: [Vnode(t2._row_id)], aggs: [count, max(t2.v2)] }
                └─StreamProject { exprs: [t2.v2, t2._row_id, Vnode(t2._row_id)] }
                  └─StreamTableScan { table: t2, columns: [t2.v2, t2._row_id], pk: [t2._row_id], dist: UpstreamHashShard(t2._row_id) }
- name: Use dynamic filter in streaming, with Top-1 on inner side
  before:
  - create_tables
  sql: |
    with max_v2 as (select v2 max from t2 order by v2 desc limit 1) select v1 from t1, max_v2 where v1 > max;
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: (t1.v1 > t2.v2), output: [t1.v1] }
    ├─LogicalScan { table: t1, columns: [t1.v1] }
    └─LogicalProject { exprs: [t2.v2] }
      └─LogicalTopN { order: "[t2.v2 DESC]", limit: 1, offset: 0 }
        └─LogicalProject { exprs: [t2.v2, t2.v2] }
          └─LogicalScan { table: t2, columns: [t2.v2] }
  stream_plan: |
    StreamMaterialize { columns: [v1, t1._row_id(hidden)], pk_columns: [t1._row_id] }
    └─StreamDynamicFilter { predicate: (t1.v1 > t2.v2), output: [t1.v1, t1._row_id] }
      ├─StreamTableScan { table: t1, columns: [t1.v1, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
      └─StreamExchange { dist: Broadcast }
        └─StreamProject { exprs: [t2.v2, t2._row_id] }
          └─StreamTopN { order: "[t2.v2 DESC]", limit: 1, offset: 0 }
            └─StreamExchange { dist: Single }
              └─StreamGroupTopN { order: "[t2.v2 DESC]", limit: 1, offset: 0, group_key: [3] }
                └─StreamProject { exprs: [t2.v2, t2.v2, t2._row_id, Vnode(t2._row_id)] }
                  └─StreamProject { exprs: [t2.v2, t2.v2, t2._row_id] }
                    └─StreamTableScan { table: t2, columns: [t2.v2, t2._row_id], pk: [t2._row_id], dist: UpstreamHashShard(t2._row_id) }
- name: Ensure error on multiple rows on inner side
  before:
  - create_tables
  sql: |
    with max_v2 as (select v2 max from t2 order by v2 desc limit 2) select v1 from t1, max_v2 where v1 > max;
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: (t1.v1 > t2.v2), output: [t1.v1] }
    ├─LogicalScan { table: t1, columns: [t1.v1] }
    └─LogicalProject { exprs: [t2.v2] }
      └─LogicalTopN { order: "[t2.v2 DESC]", limit: 2, offset: 0 }
        └─LogicalProject { exprs: [t2.v2, t2.v2] }
          └─LogicalScan { table: t2, columns: [t2.v2] }
  stream_error: |-
    Feature is not yet implemented: stream nested-loop join
    No tracking issue yet. Feel free to submit a feature request at https://github.com/risingwavelabs/risingwave/issues/new?labels=type%2Ffeature&template=feature_request.yml
- name: Ensure error on output inner columns
  before:
  - create_tables
  sql: |
    with max_v2 as (select max(v2) max from t2) select v1, max from t1, max_v2 where v1 > max;
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: (t1.v1 > max(t2.v2)), output: all }
    ├─LogicalScan { table: t1, columns: [t1.v1] }
    └─LogicalAgg { aggs: [max(t2.v2)] }
      └─LogicalScan { table: t2, columns: [t2.v2] }
  stream_error: |-
    Feature is not yet implemented: stream nested-loop join
    No tracking issue yet. Feel free to submit a feature request at https://github.com/risingwavelabs/risingwave/issues/new?labels=type%2Ffeature&template=feature_request.yml
- name: Ensure error on unsupported condition
  before:
  - create_tables
  sql: |
    with max_v2 as (select v2 max from t2 order by v2 desc limit 1) select v1 from t1, max_v2 where v1 = max;
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: (t1.v1 = t2.v2), output: [t1.v1] }
    ├─LogicalScan { table: t1, columns: [t1.v1] }
    └─LogicalProject { exprs: [t2.v2] }
      └─LogicalTopN { order: "[t2.v2 DESC]", limit: 1, offset: 0 }
        └─LogicalProject { exprs: [t2.v2, t2.v2] }
          └─LogicalScan { table: t2, columns: [t2.v2] }
  stream_plan: |
    StreamMaterialize { columns: [v1, t1._row_id(hidden), t2.v2(hidden)], pk_columns: [] }
    └─StreamHashJoin { type: Inner, predicate: t1.v1 = t2.v2, output: [t1.v1, t1._row_id, t2.v2] }
      ├─StreamExchange { dist: HashShard(t1.v1) }
      | └─StreamTableScan { table: t1, columns: [t1.v1, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
      └─StreamExchange { dist: HashShard(t2.v2) }
        └─StreamProject { exprs: [t2.v2, t2._row_id] }
          └─StreamTopN { order: "[t2.v2 DESC]", limit: 1, offset: 0 }
            └─StreamExchange { dist: Single }
              └─StreamGroupTopN { order: "[t2.v2 DESC]", limit: 1, offset: 0, group_key: [3] }
                └─StreamProject { exprs: [t2.v2, t2.v2, t2._row_id, Vnode(t2._row_id)] }
                  └─StreamProject { exprs: [t2.v2, t2.v2, t2._row_id] }
                    └─StreamTableScan { table: t2, columns: [t2.v2, t2._row_id], pk: [t2._row_id], dist: UpstreamHashShard(t2._row_id) }
