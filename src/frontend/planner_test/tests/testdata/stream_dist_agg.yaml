# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- id: create_tables
  sql: |
    /* T: updatable; Tk: Hash(k) distribution; AO: append-only; S: single distribution */
    create table T  (k int, v int, o int, s varchar);
    create index Tk on T(k) include(k, v, o, s);
    create materialized view S as select * from T order by o limit 100;
    create table AO (k int, v int, o int, s varchar) append only;
- id: extreme_on_single
  before:
  - create_tables
  sql: |
    select max(v) as a1 from S;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchSimpleAgg { aggs: [max(s.v)] }
      └─BatchScan { table: s, columns: [s.v], distribution: Single }
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [max(s.v)] }
      └─StreamGlobalSimpleAgg { aggs: [max(s.v), count] }
        └─StreamTableScan { table: s, columns: [s.v, s.o, s.t._row_id], pk: [s.t._row_id], dist: Single }
  stream_dist_plan: |
    Fragment 0
      StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
          materialized table: 4294967294
        StreamProject { exprs: [max(s.v)] }
          StreamGlobalSimpleAgg { aggs: [max(s.v), count] }
              result table: 1, state tables: [0]
            Chain { table: s, columns: [s.v, s.o, s.t._row_id], pk: [s.t._row_id], dist: Single }
              Upstream
              BatchPlanNode

     Table 0 { columns: [s_v, s_t__row_id], primary key: [$0 DESC, $1 ASC], value indices: [0, 1], distribution key: [] }
     Table 1 { columns: [max(s_v), count], primary key: [], value indices: [0, 1], distribution key: [] }
     Table 4294967294 { columns: [a1], primary key: [], value indices: [0], distribution key: [] }
- id: sum_on_single
  before:
  - create_tables
  sql: |
    select sum(v) as a1 from S;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchSimpleAgg { aggs: [sum(s.v)] }
      └─BatchScan { table: s, columns: [s.v], distribution: Single }
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [sum(s.v)] }
      └─StreamGlobalSimpleAgg { aggs: [sum(s.v), count] }
        └─StreamTableScan { table: s, columns: [s.v, s.o, s.t._row_id], pk: [s.t._row_id], dist: Single }
  stream_dist_plan: |
    Fragment 0
      StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
          materialized table: 4294967294
        StreamProject { exprs: [sum(s.v)] }
          StreamGlobalSimpleAgg { aggs: [sum(s.v), count] }
              result table: 0, state tables: []
            Chain { table: s, columns: [s.v, s.o, s.t._row_id], pk: [s.t._row_id], dist: Single }
              Upstream
              BatchPlanNode

     Table 0 { columns: [sum(s_v), count], primary key: [], value indices: [0, 1], distribution key: [] }
     Table 4294967294 { columns: [a1], primary key: [], value indices: [0], distribution key: [] }
- id: cnt_on_single
  before:
  - create_tables
  sql: |
    select count(v) as a1 from S;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchSimpleAgg { aggs: [count(s.v)] }
      └─BatchScan { table: s, columns: [s.v], distribution: Single }
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [count(s.v)] }
      └─StreamGlobalSimpleAgg { aggs: [count(s.v), count] }
        └─StreamTableScan { table: s, columns: [s.v, s.o, s.t._row_id], pk: [s.t._row_id], dist: Single }
  stream_dist_plan: |
    Fragment 0
      StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
          materialized table: 4294967294
        StreamProject { exprs: [count(s.v)] }
          StreamGlobalSimpleAgg { aggs: [count(s.v), count] }
              result table: 0, state tables: []
            Chain { table: s, columns: [s.v, s.o, s.t._row_id], pk: [s.t._row_id], dist: Single }
              Upstream
              BatchPlanNode

     Table 0 { columns: [count(s_v), count], primary key: [], value indices: [0, 1], distribution key: [] }
     Table 4294967294 { columns: [a1], primary key: [], value indices: [0], distribution key: [] }
- id: string_agg_on_single
  before:
  - create_tables
  sql: |
    select string_agg(s, ',' order by v) as a1 from S;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchSimpleAgg { aggs: [string_agg(s.s, ',':Varchar order_by(s.v ASC))] }
      └─BatchProject { exprs: [s.s, ',':Varchar, s.v] }
        └─BatchScan { table: s, columns: [s.v, s.s], distribution: Single }
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [string_agg(s.s, ',':Varchar order_by(s.v ASC))] }
      └─StreamGlobalSimpleAgg { aggs: [string_agg(s.s, ',':Varchar order_by(s.v ASC)), count] }
        └─StreamProject { exprs: [s.s, ',':Varchar, s.v, s.t._row_id] }
          └─StreamTableScan { table: s, columns: [s.v, s.s, s.o, s.t._row_id], pk: [s.t._row_id], dist: Single }
  stream_dist_plan: |
    Fragment 0
      StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
          materialized table: 4294967294
        StreamProject { exprs: [string_agg(s.s, ',':Varchar order_by(s.v ASC))] }
          StreamGlobalSimpleAgg { aggs: [string_agg(s.s, ',':Varchar order_by(s.v ASC)), count] }
              result table: 1, state tables: [0]
            StreamProject { exprs: [s.s, ',':Varchar, s.v, s.t._row_id] }
              Chain { table: s, columns: [s.v, s.s, s.o, s.t._row_id], pk: [s.t._row_id], dist: Single }
                Upstream
                BatchPlanNode

     Table 0 { columns: [s_v, s_t__row_id, s_s, ',':Varchar], primary key: [$0 ASC, $1 ASC], value indices: [0, 1, 2, 3], distribution key: [] }
     Table 1 { columns: [string_agg(s_s, ',':Varchar order_by(s_v ASC)), count], primary key: [], value indices: [0, 1], distribution key: [] }
     Table 4294967294 { columns: [a1], primary key: [], value indices: [0], distribution key: [] }
- id: extreme_on_T
  before:
  - create_tables
  sql: |
    select max(v) as a1 from T;
  batch_plan: |
    BatchSimpleAgg { aggs: [max(max(t.v))] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchSimpleAgg { aggs: [max(t.v)] }
        └─BatchScan { table: t, columns: [t.v], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [max(max(t.v))] }
      └─StreamGlobalSimpleAgg { aggs: [max(max(t.v)), count] }
        └─StreamExchange { dist: Single }
          └─StreamHashAgg { group_key: [$expr1], aggs: [max(t.v), count] }
            └─StreamProject { exprs: [t.v, t._row_id, Vnode(t._row_id) as $expr1] }
              └─StreamTableScan { table: t, columns: [t.v, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |
    Fragment 0
      StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
          materialized table: 4294967294
        StreamProject { exprs: [max(max(t.v))] }
          StreamGlobalSimpleAgg { aggs: [max(max(t.v)), count] }
              result table: 1, state tables: [0]
            StreamExchange Single from 1

    Fragment 1
      StreamHashAgg { group_key: [$expr1], aggs: [max(t.v), count] }
          result table: 3, state tables: [2]
        StreamProject { exprs: [t.v, t._row_id, Vnode(t._row_id) as $expr1] }
          Chain { table: t, columns: [t.v, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
            Upstream
            BatchPlanNode

     Table 0 { columns: [max(t_v), $expr1], primary key: [$0 DESC, $1 ASC], value indices: [0, 1], distribution key: [] }
     Table 1 { columns: [max(max(t_v)), count], primary key: [], value indices: [0, 1], distribution key: [] }
     Table 2 { columns: [$expr1, t_v, t__row_id], primary key: [$0 ASC, $1 DESC, $2 ASC], value indices: [1, 2], distribution key: [2], vnode column idx: 0 }
     Table 3 { columns: [$expr1, max(t_v), count], primary key: [$0 ASC], value indices: [1, 2], distribution key: [], vnode column idx: 0 }
     Table 4294967294 { columns: [a1], primary key: [], value indices: [0], distribution key: [] }
- id: extreme_on_AO
  before:
  - create_tables
  sql: |
    select max(v) as a1 from AO;
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [max(max(ao.v))] }
      └─StreamAppendOnlyGlobalSimpleAgg { aggs: [max(max(ao.v)), count] }
        └─StreamExchange { dist: Single }
          └─StreamStatelessLocalSimpleAgg { aggs: [max(ao.v)] }
            └─StreamTableScan { table: ao, columns: [ao.v, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |
    Fragment 0
      StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
          materialized table: 4294967294
        StreamProject { exprs: [max(max(ao.v))] }
          StreamAppendOnlyGlobalSimpleAgg { aggs: [max(max(ao.v)), count] }
              result table: 0, state tables: []
            StreamExchange Single from 1

    Fragment 1
      StreamStatelessLocalSimpleAgg { aggs: [max(ao.v)] }
        Chain { table: ao, columns: [ao.v, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
          Upstream
          BatchPlanNode

     Table 0 { columns: [max(max(ao_v)), count], primary key: [], value indices: [0, 1], distribution key: [] }
     Table 4294967294 { columns: [a1], primary key: [], value indices: [0], distribution key: [] }
- id: sum_on_T
  before:
  - create_tables
  sql: |
    select sum(v) as a1 from T;
  batch_plan: |
    BatchSimpleAgg { aggs: [sum(sum(t.v))] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchSimpleAgg { aggs: [sum(t.v)] }
        └─BatchScan { table: t, columns: [t.v], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [sum(sum(t.v))] }
      └─StreamGlobalSimpleAgg { aggs: [sum(sum(t.v)), count] }
        └─StreamExchange { dist: Single }
          └─StreamStatelessLocalSimpleAgg { aggs: [sum(t.v)] }
            └─StreamTableScan { table: t, columns: [t.v, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |
    Fragment 0
      StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
          materialized table: 4294967294
        StreamProject { exprs: [sum(sum(t.v))] }
          StreamGlobalSimpleAgg { aggs: [sum(sum(t.v)), count] }
              result table: 0, state tables: []
            StreamExchange Single from 1

    Fragment 1
      StreamStatelessLocalSimpleAgg { aggs: [sum(t.v)] }
        Chain { table: t, columns: [t.v, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
          Upstream
          BatchPlanNode

     Table 0 { columns: [sum(sum(t_v)), count], primary key: [], value indices: [0, 1], distribution key: [] }
     Table 4294967294 { columns: [a1], primary key: [], value indices: [0], distribution key: [] }
- id: sum_on_AO
  before:
  - create_tables
  sql: |
    select sum(v) as a1 from AO;
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [sum(sum(ao.v))] }
      └─StreamAppendOnlyGlobalSimpleAgg { aggs: [sum(sum(ao.v)), count] }
        └─StreamExchange { dist: Single }
          └─StreamStatelessLocalSimpleAgg { aggs: [sum(ao.v)] }
            └─StreamTableScan { table: ao, columns: [ao.v, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |
    Fragment 0
      StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
          materialized table: 4294967294
        StreamProject { exprs: [sum(sum(ao.v))] }
          StreamAppendOnlyGlobalSimpleAgg { aggs: [sum(sum(ao.v)), count] }
              result table: 0, state tables: []
            StreamExchange Single from 1

    Fragment 1
      StreamStatelessLocalSimpleAgg { aggs: [sum(ao.v)] }
        Chain { table: ao, columns: [ao.v, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
          Upstream
          BatchPlanNode

     Table 0 { columns: [sum(sum(ao_v)), count], primary key: [], value indices: [0, 1], distribution key: [] }
     Table 4294967294 { columns: [a1], primary key: [], value indices: [0], distribution key: [] }
- id: cnt_on_T
  before:
  - create_tables
  sql: |
    select count(v) as a1 from T;
  batch_plan: |
    BatchSimpleAgg { aggs: [sum0(count(t.v))] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchSimpleAgg { aggs: [count(t.v)] }
        └─BatchScan { table: t, columns: [t.v], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [sum0(count(t.v))] }
      └─StreamGlobalSimpleAgg { aggs: [sum0(count(t.v)), count] }
        └─StreamExchange { dist: Single }
          └─StreamStatelessLocalSimpleAgg { aggs: [count(t.v)] }
            └─StreamTableScan { table: t, columns: [t.v, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |
    Fragment 0
      StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
          materialized table: 4294967294
        StreamProject { exprs: [sum0(count(t.v))] }
          StreamGlobalSimpleAgg { aggs: [sum0(count(t.v)), count] }
              result table: 0, state tables: []
            StreamExchange Single from 1

    Fragment 1
      StreamStatelessLocalSimpleAgg { aggs: [count(t.v)] }
        Chain { table: t, columns: [t.v, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
          Upstream
          BatchPlanNode

     Table 0 { columns: [sum0(count(t_v)), count], primary key: [], value indices: [0, 1], distribution key: [] }
     Table 4294967294 { columns: [a1], primary key: [], value indices: [0], distribution key: [] }
- id: cnt_on_AO
  before:
  - create_tables
  sql: |
    select count(v) as a1 from AO;
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [sum0(count(ao.v))] }
      └─StreamAppendOnlyGlobalSimpleAgg { aggs: [sum0(count(ao.v)), count] }
        └─StreamExchange { dist: Single }
          └─StreamStatelessLocalSimpleAgg { aggs: [count(ao.v)] }
            └─StreamTableScan { table: ao, columns: [ao.v, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |
    Fragment 0
      StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
          materialized table: 4294967294
        StreamProject { exprs: [sum0(count(ao.v))] }
          StreamAppendOnlyGlobalSimpleAgg { aggs: [sum0(count(ao.v)), count] }
              result table: 0, state tables: []
            StreamExchange Single from 1

    Fragment 1
      StreamStatelessLocalSimpleAgg { aggs: [count(ao.v)] }
        Chain { table: ao, columns: [ao.v, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
          Upstream
          BatchPlanNode

     Table 0 { columns: [sum0(count(ao_v)), count], primary key: [], value indices: [0, 1], distribution key: [] }
     Table 4294967294 { columns: [a1], primary key: [], value indices: [0], distribution key: [] }
- id: string_agg_on_T
  before:
  - create_tables
  sql: |
    select string_agg(s, ',' order by o) as a1 from T;
  batch_plan: |
    BatchSimpleAgg { aggs: [string_agg(t.s, ',':Varchar order_by(t.o ASC))] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchProject { exprs: [t.s, ',':Varchar, t.o] }
        └─BatchScan { table: t, columns: [t.o, t.s], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [string_agg(t.s, ',':Varchar order_by(t.o ASC))] }
      └─StreamGlobalSimpleAgg { aggs: [string_agg(t.s, ',':Varchar order_by(t.o ASC)), count] }
        └─StreamExchange { dist: Single }
          └─StreamProject { exprs: [t.s, ',':Varchar, t.o, t._row_id] }
            └─StreamTableScan { table: t, columns: [t.o, t.s, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |
    Fragment 0
      StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
          materialized table: 4294967294
        StreamProject { exprs: [string_agg(t.s, ',':Varchar order_by(t.o ASC))] }
          StreamGlobalSimpleAgg { aggs: [string_agg(t.s, ',':Varchar order_by(t.o ASC)), count] }
              result table: 1, state tables: [0]
            StreamExchange Single from 1

    Fragment 1
      StreamProject { exprs: [t.s, ',':Varchar, t.o, t._row_id] }
        Chain { table: t, columns: [t.o, t.s, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
          Upstream
          BatchPlanNode

     Table 0 { columns: [t_o, t__row_id, t_s, ',':Varchar], primary key: [$0 ASC, $1 ASC], value indices: [0, 1, 2, 3], distribution key: [] }
     Table 1 { columns: [string_agg(t_s, ',':Varchar order_by(t_o ASC)), count], primary key: [], value indices: [0, 1], distribution key: [] }
     Table 4294967294 { columns: [a1], primary key: [], value indices: [0], distribution key: [] }
- id: string_agg_on_AO
  before:
  - create_tables
  sql: |
    select string_agg(s, ',' order by o) as a1 from AO;
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [string_agg(ao.s, ',':Varchar order_by(ao.o ASC))] }
      └─StreamAppendOnlyGlobalSimpleAgg { aggs: [string_agg(ao.s, ',':Varchar order_by(ao.o ASC)), count] }
        └─StreamExchange { dist: Single }
          └─StreamProject { exprs: [ao.s, ',':Varchar, ao.o, ao._row_id] }
            └─StreamTableScan { table: ao, columns: [ao.o, ao.s, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |
    Fragment 0
      StreamMaterialize { columns: [a1], pk_columns: [], pk_conflict: "no check" }
          materialized table: 4294967294
        StreamProject { exprs: [string_agg(ao.s, ',':Varchar order_by(ao.o ASC))] }
          StreamAppendOnlyGlobalSimpleAgg { aggs: [string_agg(ao.s, ',':Varchar order_by(ao.o ASC)), count] }
              result table: 0, state tables: []
            StreamExchange Single from 1

    Fragment 1
      StreamProject { exprs: [ao.s, ',':Varchar, ao.o, ao._row_id] }
        Chain { table: ao, columns: [ao.o, ao.s, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
          Upstream
          BatchPlanNode

     Table 0 { columns: [string_agg(ao_s, ',':Varchar order_by(ao_o ASC)), count], primary key: [], value indices: [0, 1], distribution key: [] }
     Table 4294967294 { columns: [a1], primary key: [], value indices: [0], distribution key: [] }
- id: extreme_count_on_T
  before:
  - create_tables
  sql: |
    select max(v) as a1, count(v) as a2 from T;
  batch_plan: |
    BatchSimpleAgg { aggs: [max(max(t.v)), sum0(count(t.v))] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchSimpleAgg { aggs: [max(t.v), count(t.v)] }
        └─BatchScan { table: t, columns: [t.v], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1, a2], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [max(max(t.v)), sum0(count(t.v))] }
      └─StreamGlobalSimpleAgg { aggs: [max(max(t.v)), sum0(count(t.v)), count] }
        └─StreamExchange { dist: Single }
          └─StreamHashAgg { group_key: [$expr1], aggs: [max(t.v), count(t.v), count] }
            └─StreamProject { exprs: [t.v, t._row_id, Vnode(t._row_id) as $expr1] }
              └─StreamTableScan { table: t, columns: [t.v, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |
    Fragment 0
      StreamMaterialize { columns: [a1, a2], pk_columns: [], pk_conflict: "no check" }
          materialized table: 4294967294
        StreamProject { exprs: [max(max(t.v)), sum0(count(t.v))] }
          StreamGlobalSimpleAgg { aggs: [max(max(t.v)), sum0(count(t.v)), count] }
              result table: 1, state tables: [0]
            StreamExchange Single from 1

    Fragment 1
      StreamHashAgg { group_key: [$expr1], aggs: [max(t.v), count(t.v), count] }
          result table: 3, state tables: [2]
        StreamProject { exprs: [t.v, t._row_id, Vnode(t._row_id) as $expr1] }
          Chain { table: t, columns: [t.v, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
            Upstream
            BatchPlanNode

     Table 0 { columns: [max(t_v), $expr1], primary key: [$0 DESC, $1 ASC], value indices: [0, 1], distribution key: [] }
     Table 1 { columns: [max(max(t_v)), sum0(count(t_v)), count], primary key: [], value indices: [0, 1, 2], distribution key: [] }
     Table 2 { columns: [$expr1, t_v, t__row_id], primary key: [$0 ASC, $1 DESC, $2 ASC], value indices: [1, 2], distribution key: [2], vnode column idx: 0 }
     Table 3 { columns: [$expr1, max(t_v), count(t_v), count], primary key: [$0 ASC], value indices: [1, 2, 3], distribution key: [], vnode column idx: 0 }
     Table 4294967294 { columns: [a1, a2], primary key: [], value indices: [0, 1], distribution key: [] }
- id: extreme_count_on_AO
  before:
  - create_tables
  sql: |
    select max(v) as a1, count(v) as a2 from AO;
  stream_plan: |
    StreamMaterialize { columns: [a1, a2], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [max(max(ao.v)), sum0(count(ao.v))] }
      └─StreamAppendOnlyGlobalSimpleAgg { aggs: [max(max(ao.v)), sum0(count(ao.v)), count] }
        └─StreamExchange { dist: Single }
          └─StreamStatelessLocalSimpleAgg { aggs: [max(ao.v), count(ao.v)] }
            └─StreamTableScan { table: ao, columns: [ao.v, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |
    Fragment 0
      StreamMaterialize { columns: [a1, a2], pk_columns: [], pk_conflict: "no check" }
          materialized table: 4294967294
        StreamProject { exprs: [max(max(ao.v)), sum0(count(ao.v))] }
          StreamAppendOnlyGlobalSimpleAgg { aggs: [max(max(ao.v)), sum0(count(ao.v)), count] }
              result table: 0, state tables: []
            StreamExchange Single from 1

    Fragment 1
      StreamStatelessLocalSimpleAgg { aggs: [max(ao.v), count(ao.v)] }
        Chain { table: ao, columns: [ao.v, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
          Upstream
          BatchPlanNode

     Table 0 { columns: [max(max(ao_v)), sum0(count(ao_v)), count], primary key: [], value indices: [0, 1, 2], distribution key: [] }
     Table 4294967294 { columns: [a1, a2], primary key: [], value indices: [0, 1], distribution key: [] }
- id: count_string_agg_on_T
  before:
  - create_tables
  sql: |
    select count(v) as a1, string_agg(s, ',' order by o) as a2 from T;
  batch_plan: |
    BatchSimpleAgg { aggs: [count(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC))] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchProject { exprs: [t.v, t.s, ',':Varchar, t.o] }
        └─BatchScan { table: t, columns: [t.v, t.o, t.s], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1, a2], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [count(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC))] }
      └─StreamGlobalSimpleAgg { aggs: [count(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC)), count] }
        └─StreamExchange { dist: Single }
          └─StreamProject { exprs: [t.v, t.s, ',':Varchar, t.o, t._row_id] }
            └─StreamTableScan { table: t, columns: [t.v, t.o, t.s, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |
    Fragment 0
      StreamMaterialize { columns: [a1, a2], pk_columns: [], pk_conflict: "no check" }
          materialized table: 4294967294
        StreamProject { exprs: [count(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC))] }
          StreamGlobalSimpleAgg { aggs: [count(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC)), count] }
              result table: 1, state tables: [0]
            StreamExchange Single from 1

    Fragment 1
      StreamProject { exprs: [t.v, t.s, ',':Varchar, t.o, t._row_id] }
        Chain { table: t, columns: [t.v, t.o, t.s, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
          Upstream
          BatchPlanNode

     Table 0 { columns: [t_o, t__row_id, t_s, ',':Varchar], primary key: [$0 ASC, $1 ASC], value indices: [0, 1, 2, 3], distribution key: [] }
     Table 1 { columns: [count(t_v), string_agg(t_s, ',':Varchar order_by(t_o ASC)), count], primary key: [], value indices: [0, 1, 2], distribution key: [] }
     Table 4294967294 { columns: [a1, a2], primary key: [], value indices: [0, 1], distribution key: [] }
- id: count_string_agg_on_AO
  before:
  - create_tables
  sql: |
    select count(v) as a1, string_agg(s, ',' order by o) as a2 from AO;
  stream_plan: |
    StreamMaterialize { columns: [a1, a2], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [count(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC))] }
      └─StreamAppendOnlyGlobalSimpleAgg { aggs: [count(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC)), count] }
        └─StreamExchange { dist: Single }
          └─StreamProject { exprs: [ao.v, ao.s, ',':Varchar, ao.o, ao._row_id] }
            └─StreamTableScan { table: ao, columns: [ao.v, ao.o, ao.s, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |
    Fragment 0
      StreamMaterialize { columns: [a1, a2], pk_columns: [], pk_conflict: "no check" }
          materialized table: 4294967294
        StreamProject { exprs: [count(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC))] }
          StreamAppendOnlyGlobalSimpleAgg { aggs: [count(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC)), count] }
              result table: 0, state tables: []
            StreamExchange Single from 1

    Fragment 1
      StreamProject { exprs: [ao.v, ao.s, ',':Varchar, ao.o, ao._row_id] }
        Chain { table: ao, columns: [ao.v, ao.o, ao.s, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
          Upstream
          BatchPlanNode

     Table 0 { columns: [count(ao_v), string_agg(ao_s, ',':Varchar order_by(ao_o ASC)), count], primary key: [], value indices: [0, 1, 2], distribution key: [] }
     Table 4294967294 { columns: [a1, a2], primary key: [], value indices: [0, 1], distribution key: [] }
- id: extreme_string_agg_on_T
  before:
  - create_tables
  sql: |
    select max(v) as a1, string_agg(s, ',' order by o) as a2 from T;
  batch_plan: |
    BatchSimpleAgg { aggs: [max(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC))] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchProject { exprs: [t.v, t.s, ',':Varchar, t.o] }
        └─BatchScan { table: t, columns: [t.v, t.o, t.s], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1, a2], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [max(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC))] }
      └─StreamGlobalSimpleAgg { aggs: [max(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC)), count] }
        └─StreamExchange { dist: Single }
          └─StreamProject { exprs: [t.v, t.s, ',':Varchar, t.o, t._row_id] }
            └─StreamTableScan { table: t, columns: [t.v, t.o, t.s, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |
    Fragment 0
      StreamMaterialize { columns: [a1, a2], pk_columns: [], pk_conflict: "no check" }
          materialized table: 4294967294
        StreamProject { exprs: [max(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC))] }
          StreamGlobalSimpleAgg { aggs: [max(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC)), count] }
              result table: 2, state tables: [0, 1]
            StreamExchange Single from 1

    Fragment 1
      StreamProject { exprs: [t.v, t.s, ',':Varchar, t.o, t._row_id] }
        Chain { table: t, columns: [t.v, t.o, t.s, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
          Upstream
          BatchPlanNode

     Table 0 { columns: [t_v, t__row_id], primary key: [$0 DESC, $1 ASC], value indices: [0, 1], distribution key: [] }
     Table 1 { columns: [t_o, t__row_id, t_s, ',':Varchar], primary key: [$0 ASC, $1 ASC], value indices: [0, 1, 2, 3], distribution key: [] }
     Table 2 { columns: [max(t_v), string_agg(t_s, ',':Varchar order_by(t_o ASC)), count], primary key: [], value indices: [0, 1, 2], distribution key: [] }
     Table 4294967294 { columns: [a1, a2], primary key: [], value indices: [0, 1], distribution key: [] }
- id: extreme_string_agg_on_AO
  before:
  - create_tables
  sql: |
    select max(v) as a1, string_agg(s, ',' order by o) as a2 from AO;
  stream_plan: |
    StreamMaterialize { columns: [a1, a2], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [max(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC))] }
      └─StreamAppendOnlyGlobalSimpleAgg { aggs: [max(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC)), count] }
        └─StreamExchange { dist: Single }
          └─StreamProject { exprs: [ao.v, ao.s, ',':Varchar, ao.o, ao._row_id] }
            └─StreamTableScan { table: ao, columns: [ao.v, ao.o, ao.s, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |
    Fragment 0
      StreamMaterialize { columns: [a1, a2], pk_columns: [], pk_conflict: "no check" }
          materialized table: 4294967294
        StreamProject { exprs: [max(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC))] }
          StreamAppendOnlyGlobalSimpleAgg { aggs: [max(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC)), count] }
              result table: 0, state tables: []
            StreamExchange Single from 1

    Fragment 1
      StreamProject { exprs: [ao.v, ao.s, ',':Varchar, ao.o, ao._row_id] }
        Chain { table: ao, columns: [ao.v, ao.o, ao.s, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
          Upstream
          BatchPlanNode

     Table 0 { columns: [max(ao_v), string_agg(ao_s, ',':Varchar order_by(ao_o ASC)), count], primary key: [], value indices: [0, 1, 2], distribution key: [] }
     Table 4294967294 { columns: [a1, a2], primary key: [], value indices: [0, 1], distribution key: [] }
- id: extreme_on_T_by_k
  before:
  - create_tables
  sql: |
    select max(v) as a1 from T group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [max(t.v)] }
      └─BatchHashAgg { group_key: [t.k], aggs: [max(t.v)] }
        └─BatchExchange { order: [], dist: HashShard(t.k) }
          └─BatchScan { table: t, columns: [t.k, t.v], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1, t.k(hidden)], pk_columns: [t.k], pk_conflict: "no check" }
    └─StreamProject { exprs: [max(t.v), t.k] }
      └─StreamHashAgg { group_key: [t.k], aggs: [max(t.v), count] }
        └─StreamExchange { dist: HashShard(t.k) }
          └─StreamTableScan { table: t, columns: [t.k, t.v, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |
    Fragment 0
      StreamMaterialize { columns: [a1, t.k(hidden)], pk_columns: [t.k], pk_conflict: "no check" }
          materialized table: 4294967294
        StreamProject { exprs: [max(t.v), t.k] }
          StreamHashAgg { group_key: [t.k], aggs: [max(t.v), count] }
              result table: 1, state tables: [0]
            StreamExchange Hash([0]) from 1

    Fragment 1
      Chain { table: t, columns: [t.k, t.v, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
        Upstream
        BatchPlanNode

     Table 0 { columns: [t_k, t_v, t__row_id], primary key: [$0 ASC, $1 DESC, $2 ASC], value indices: [1, 2], distribution key: [0] }
     Table 1 { columns: [t_k, max(t_v), count], primary key: [$0 ASC], value indices: [1, 2], distribution key: [0] }
     Table 4294967294 { columns: [a1, t.k], primary key: [$1 ASC], value indices: [0, 1], distribution key: [1] }
- id: extreme_on_Tk_by_k
  before:
  - create_tables
  sql: |
    select max(v) as a1 from Tk group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [max(tk.v)] }
      └─BatchSortAgg { group_key: [tk.k], aggs: [max(tk.v)] }
        └─BatchScan { table: tk, columns: [tk.k, tk.v], distribution: UpstreamHashShard(tk.k) }
  stream_plan: |
    StreamMaterialize { columns: [a1, tk.k(hidden)], pk_columns: [tk.k], pk_conflict: "no check" }
    └─StreamProject { exprs: [max(tk.v), tk.k] }
      └─StreamHashAgg { group_key: [tk.k], aggs: [max(tk.v), count] }
        └─StreamTableScan { table: tk, columns: [tk.k, tk.v, tk.t._row_id], pk: [tk.t._row_id], dist: UpstreamHashShard(tk.k) }
  stream_dist_plan: |
    Fragment 0
      StreamMaterialize { columns: [a1, tk.k(hidden)], pk_columns: [tk.k], pk_conflict: "no check" }
          materialized table: 4294967294
        StreamProject { exprs: [max(tk.v), tk.k] }
          StreamHashAgg { group_key: [tk.k], aggs: [max(tk.v), count] }
              result table: 1, state tables: [0]
            Chain { table: tk, columns: [tk.k, tk.v, tk.t._row_id], pk: [tk.t._row_id], dist: UpstreamHashShard(tk.k) }
              Upstream
              BatchPlanNode

     Table 0 { columns: [tk_k, tk_v, tk_t__row_id], primary key: [$0 ASC, $1 DESC, $2 ASC], value indices: [1, 2], distribution key: [0] }
     Table 1 { columns: [tk_k, max(tk_v), count], primary key: [$0 ASC], value indices: [1, 2], distribution key: [0] }
     Table 4294967294 { columns: [a1, tk.k], primary key: [$1 ASC], value indices: [0, 1], distribution key: [1] }
- id: extreme_on_S_by_k
  before:
  - create_tables
  sql: |
    select max(v) as a1 from S group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [max(s.v)] }
      └─BatchHashAgg { group_key: [s.k], aggs: [max(s.v)] }
        └─BatchExchange { order: [], dist: HashShard(s.k) }
          └─BatchScan { table: s, columns: [s.k, s.v], distribution: Single }
  stream_plan: |
    StreamMaterialize { columns: [a1, s.k(hidden)], pk_columns: [s.k], pk_conflict: "no check" }
    └─StreamProject { exprs: [max(s.v), s.k] }
      └─StreamHashAgg { group_key: [s.k], aggs: [max(s.v), count] }
        └─StreamExchange { dist: HashShard(s.k) }
          └─StreamTableScan { table: s, columns: [s.k, s.v, s.o, s.t._row_id], pk: [s.t._row_id], dist: Single }
  stream_dist_plan: |
    Fragment 0
      StreamMaterialize { columns: [a1, s.k(hidden)], pk_columns: [s.k], pk_conflict: "no check" }
          materialized table: 4294967294
        StreamProject { exprs: [max(s.v), s.k] }
          StreamHashAgg { group_key: [s.k], aggs: [max(s.v), count] }
              result table: 1, state tables: [0]
            StreamExchange Hash([0]) from 1

    Fragment 1
      Chain { table: s, columns: [s.k, s.v, s.o, s.t._row_id], pk: [s.t._row_id], dist: Single }
        Upstream
        BatchPlanNode

     Table 0 { columns: [s_k, s_v, s_t__row_id], primary key: [$0 ASC, $1 DESC, $2 ASC], value indices: [1, 2], distribution key: [0] }
     Table 1 { columns: [s_k, max(s_v), count], primary key: [$0 ASC], value indices: [1, 2], distribution key: [0] }
     Table 4294967294 { columns: [a1, s.k], primary key: [$1 ASC], value indices: [0, 1], distribution key: [1] }
- id: extreme_on_AO_by_k
  before:
  - create_tables
  sql: |
    select max(v) as a1 from AO group by k;
  stream_plan: |
    StreamMaterialize { columns: [a1, ao.k(hidden)], pk_columns: [ao.k], pk_conflict: "no check" }
    └─StreamProject { exprs: [max(ao.v), ao.k] }
      └─StreamAppendOnlyHashAgg { group_key: [ao.k], aggs: [max(ao.v), count] }
        └─StreamExchange { dist: HashShard(ao.k) }
          └─StreamTableScan { table: ao, columns: [ao.k, ao.v, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |
    Fragment 0
      StreamMaterialize { columns: [a1, ao.k(hidden)], pk_columns: [ao.k], pk_conflict: "no check" }
          materialized table: 4294967294
        StreamProject { exprs: [max(ao.v), ao.k] }
          StreamAppendOnlyHashAgg { group_key: [ao.k], aggs: [max(ao.v), count] }
              result table: 0, state tables: []
            StreamExchange Hash([0]) from 1

    Fragment 1
      Chain { table: ao, columns: [ao.k, ao.v, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
        Upstream
        BatchPlanNode

     Table 0 { columns: [ao_k, max(ao_v), count], primary key: [$0 ASC], value indices: [1, 2], distribution key: [0] }
     Table 4294967294 { columns: [a1, ao.k], primary key: [$1 ASC], value indices: [0, 1], distribution key: [1] }
- id: sum_on_T_by_k
  before:
  - create_tables
  sql: |
    select sum(v) as a1 from T group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [sum(t.v)] }
      └─BatchHashAgg { group_key: [t.k], aggs: [sum(t.v)] }
        └─BatchExchange { order: [], dist: HashShard(t.k) }
          └─BatchScan { table: t, columns: [t.k, t.v], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1, t.k(hidden)], pk_columns: [t.k], pk_conflict: "no check" }
    └─StreamProject { exprs: [sum(t.v), t.k] }
      └─StreamHashAgg { group_key: [t.k], aggs: [sum(t.v), count] }
        └─StreamExchange { dist: HashShard(t.k) }
          └─StreamTableScan { table: t, columns: [t.k, t.v, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |
    Fragment 0
      StreamMaterialize { columns: [a1, t.k(hidden)], pk_columns: [t.k], pk_conflict: "no check" }
          materialized table: 4294967294
        StreamProject { exprs: [sum(t.v), t.k] }
          StreamHashAgg { group_key: [t.k], aggs: [sum(t.v), count] }
              result table: 0, state tables: []
            StreamExchange Hash([0]) from 1

    Fragment 1
      Chain { table: t, columns: [t.k, t.v, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
        Upstream
        BatchPlanNode

     Table 0 { columns: [t_k, sum(t_v), count], primary key: [$0 ASC], value indices: [1, 2], distribution key: [0] }
     Table 4294967294 { columns: [a1, t.k], primary key: [$1 ASC], value indices: [0, 1], distribution key: [1] }
- id: sum_on_Tk_by_k
  before:
  - create_tables
  sql: |
    select sum(v) as a1 from Tk group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [sum(tk.v)] }
      └─BatchSortAgg { group_key: [tk.k], aggs: [sum(tk.v)] }
        └─BatchScan { table: tk, columns: [tk.k, tk.v], distribution: UpstreamHashShard(tk.k) }
  stream_plan: |
    StreamMaterialize { columns: [a1, tk.k(hidden)], pk_columns: [tk.k], pk_conflict: "no check" }
    └─StreamProject { exprs: [sum(tk.v), tk.k] }
      └─StreamHashAgg { group_key: [tk.k], aggs: [sum(tk.v), count] }
        └─StreamTableScan { table: tk, columns: [tk.k, tk.v, tk.t._row_id], pk: [tk.t._row_id], dist: UpstreamHashShard(tk.k) }
  stream_dist_plan: |
    Fragment 0
      StreamMaterialize { columns: [a1, tk.k(hidden)], pk_columns: [tk.k], pk_conflict: "no check" }
          materialized table: 4294967294
        StreamProject { exprs: [sum(tk.v), tk.k] }
          StreamHashAgg { group_key: [tk.k], aggs: [sum(tk.v), count] }
              result table: 0, state tables: []
            Chain { table: tk, columns: [tk.k, tk.v, tk.t._row_id], pk: [tk.t._row_id], dist: UpstreamHashShard(tk.k) }
              Upstream
              BatchPlanNode

     Table 0 { columns: [tk_k, sum(tk_v), count], primary key: [$0 ASC], value indices: [1, 2], distribution key: [0] }
     Table 4294967294 { columns: [a1, tk.k], primary key: [$1 ASC], value indices: [0, 1], distribution key: [1] }
- id: sum_on_S_by_k
  before:
  - create_tables
  sql: |
    select sum(v) as a1 from S group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [sum(s.v)] }
      └─BatchHashAgg { group_key: [s.k], aggs: [sum(s.v)] }
        └─BatchExchange { order: [], dist: HashShard(s.k) }
          └─BatchScan { table: s, columns: [s.k, s.v], distribution: Single }
  stream_plan: |
    StreamMaterialize { columns: [a1, s.k(hidden)], pk_columns: [s.k], pk_conflict: "no check" }
    └─StreamProject { exprs: [sum(s.v), s.k] }
      └─StreamHashAgg { group_key: [s.k], aggs: [sum(s.v), count] }
        └─StreamExchange { dist: HashShard(s.k) }
          └─StreamTableScan { table: s, columns: [s.k, s.v, s.o, s.t._row_id], pk: [s.t._row_id], dist: Single }
  stream_dist_plan: |
    Fragment 0
      StreamMaterialize { columns: [a1, s.k(hidden)], pk_columns: [s.k], pk_conflict: "no check" }
          materialized table: 4294967294
        StreamProject { exprs: [sum(s.v), s.k] }
          StreamHashAgg { group_key: [s.k], aggs: [sum(s.v), count] }
              result table: 0, state tables: []
            StreamExchange Hash([0]) from 1

    Fragment 1
      Chain { table: s, columns: [s.k, s.v, s.o, s.t._row_id], pk: [s.t._row_id], dist: Single }
        Upstream
        BatchPlanNode

     Table 0 { columns: [s_k, sum(s_v), count], primary key: [$0 ASC], value indices: [1, 2], distribution key: [0] }
     Table 4294967294 { columns: [a1, s.k], primary key: [$1 ASC], value indices: [0, 1], distribution key: [1] }
- id: sum_on_AO_by_k
  before:
  - create_tables
  sql: |
    select sum(v) as a1 from AO group by k;
  stream_plan: |
    StreamMaterialize { columns: [a1, ao.k(hidden)], pk_columns: [ao.k], pk_conflict: "no check" }
    └─StreamProject { exprs: [sum(ao.v), ao.k] }
      └─StreamAppendOnlyHashAgg { group_key: [ao.k], aggs: [sum(ao.v), count] }
        └─StreamExchange { dist: HashShard(ao.k) }
          └─StreamTableScan { table: ao, columns: [ao.k, ao.v, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |
    Fragment 0
      StreamMaterialize { columns: [a1, ao.k(hidden)], pk_columns: [ao.k], pk_conflict: "no check" }
          materialized table: 4294967294
        StreamProject { exprs: [sum(ao.v), ao.k] }
          StreamAppendOnlyHashAgg { group_key: [ao.k], aggs: [sum(ao.v), count] }
              result table: 0, state tables: []
            StreamExchange Hash([0]) from 1

    Fragment 1
      Chain { table: ao, columns: [ao.k, ao.v, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
        Upstream
        BatchPlanNode

     Table 0 { columns: [ao_k, sum(ao_v), count], primary key: [$0 ASC], value indices: [1, 2], distribution key: [0] }
     Table 4294967294 { columns: [a1, ao.k], primary key: [$1 ASC], value indices: [0, 1], distribution key: [1] }
- id: cnt_on_T_by_k
  before:
  - create_tables
  sql: |
    select count(v) as a1 from T group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [count(t.v)] }
      └─BatchHashAgg { group_key: [t.k], aggs: [count(t.v)] }
        └─BatchExchange { order: [], dist: HashShard(t.k) }
          └─BatchScan { table: t, columns: [t.k, t.v], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1, t.k(hidden)], pk_columns: [t.k], pk_conflict: "no check" }
    └─StreamProject { exprs: [count(t.v), t.k] }
      └─StreamHashAgg { group_key: [t.k], aggs: [count(t.v), count] }
        └─StreamExchange { dist: HashShard(t.k) }
          └─StreamTableScan { table: t, columns: [t.k, t.v, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |
    Fragment 0
      StreamMaterialize { columns: [a1, t.k(hidden)], pk_columns: [t.k], pk_conflict: "no check" }
          materialized table: 4294967294
        StreamProject { exprs: [count(t.v), t.k] }
          StreamHashAgg { group_key: [t.k], aggs: [count(t.v), count] }
              result table: 0, state tables: []
            StreamExchange Hash([0]) from 1

    Fragment 1
      Chain { table: t, columns: [t.k, t.v, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
        Upstream
        BatchPlanNode

     Table 0 { columns: [t_k, count(t_v), count], primary key: [$0 ASC], value indices: [1, 2], distribution key: [0] }
     Table 4294967294 { columns: [a1, t.k], primary key: [$1 ASC], value indices: [0, 1], distribution key: [1] }
- id: cnt_on_Tk_by_k
  before:
  - create_tables
  sql: |
    select count(v) as a1 from Tk group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [count(tk.v)] }
      └─BatchSortAgg { group_key: [tk.k], aggs: [count(tk.v)] }
        └─BatchScan { table: tk, columns: [tk.k, tk.v], distribution: UpstreamHashShard(tk.k) }
  stream_plan: |
    StreamMaterialize { columns: [a1, tk.k(hidden)], pk_columns: [tk.k], pk_conflict: "no check" }
    └─StreamProject { exprs: [count(tk.v), tk.k] }
      └─StreamHashAgg { group_key: [tk.k], aggs: [count(tk.v), count] }
        └─StreamTableScan { table: tk, columns: [tk.k, tk.v, tk.t._row_id], pk: [tk.t._row_id], dist: UpstreamHashShard(tk.k) }
  stream_dist_plan: |
    Fragment 0
      StreamMaterialize { columns: [a1, tk.k(hidden)], pk_columns: [tk.k], pk_conflict: "no check" }
          materialized table: 4294967294
        StreamProject { exprs: [count(tk.v), tk.k] }
          StreamHashAgg { group_key: [tk.k], aggs: [count(tk.v), count] }
              result table: 0, state tables: []
            Chain { table: tk, columns: [tk.k, tk.v, tk.t._row_id], pk: [tk.t._row_id], dist: UpstreamHashShard(tk.k) }
              Upstream
              BatchPlanNode

     Table 0 { columns: [tk_k, count(tk_v), count], primary key: [$0 ASC], value indices: [1, 2], distribution key: [0] }
     Table 4294967294 { columns: [a1, tk.k], primary key: [$1 ASC], value indices: [0, 1], distribution key: [1] }
- id: cnt_on_S_by_k
  before:
  - create_tables
  sql: |
    select count(v) as a1 from S group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [count(s.v)] }
      └─BatchHashAgg { group_key: [s.k], aggs: [count(s.v)] }
        └─BatchExchange { order: [], dist: HashShard(s.k) }
          └─BatchScan { table: s, columns: [s.k, s.v], distribution: Single }
  stream_plan: |
    StreamMaterialize { columns: [a1, s.k(hidden)], pk_columns: [s.k], pk_conflict: "no check" }
    └─StreamProject { exprs: [count(s.v), s.k] }
      └─StreamHashAgg { group_key: [s.k], aggs: [count(s.v), count] }
        └─StreamExchange { dist: HashShard(s.k) }
          └─StreamTableScan { table: s, columns: [s.k, s.v, s.o, s.t._row_id], pk: [s.t._row_id], dist: Single }
  stream_dist_plan: |
    Fragment 0
      StreamMaterialize { columns: [a1, s.k(hidden)], pk_columns: [s.k], pk_conflict: "no check" }
          materialized table: 4294967294
        StreamProject { exprs: [count(s.v), s.k] }
          StreamHashAgg { group_key: [s.k], aggs: [count(s.v), count] }
              result table: 0, state tables: []
            StreamExchange Hash([0]) from 1

    Fragment 1
      Chain { table: s, columns: [s.k, s.v, s.o, s.t._row_id], pk: [s.t._row_id], dist: Single }
        Upstream
        BatchPlanNode

     Table 0 { columns: [s_k, count(s_v), count], primary key: [$0 ASC], value indices: [1, 2], distribution key: [0] }
     Table 4294967294 { columns: [a1, s.k], primary key: [$1 ASC], value indices: [0, 1], distribution key: [1] }
- id: cnt_on_AO_by_k
  before:
  - create_tables
  sql: |
    select count(v) as a1 from AO group by k;
  stream_plan: |
    StreamMaterialize { columns: [a1, ao.k(hidden)], pk_columns: [ao.k], pk_conflict: "no check" }
    └─StreamProject { exprs: [count(ao.v), ao.k] }
      └─StreamAppendOnlyHashAgg { group_key: [ao.k], aggs: [count(ao.v), count] }
        └─StreamExchange { dist: HashShard(ao.k) }
          └─StreamTableScan { table: ao, columns: [ao.k, ao.v, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |
    Fragment 0
      StreamMaterialize { columns: [a1, ao.k(hidden)], pk_columns: [ao.k], pk_conflict: "no check" }
          materialized table: 4294967294
        StreamProject { exprs: [count(ao.v), ao.k] }
          StreamAppendOnlyHashAgg { group_key: [ao.k], aggs: [count(ao.v), count] }
              result table: 0, state tables: []
            StreamExchange Hash([0]) from 1

    Fragment 1
      Chain { table: ao, columns: [ao.k, ao.v, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
        Upstream
        BatchPlanNode

     Table 0 { columns: [ao_k, count(ao_v), count], primary key: [$0 ASC], value indices: [1, 2], distribution key: [0] }
     Table 4294967294 { columns: [a1, ao.k], primary key: [$1 ASC], value indices: [0, 1], distribution key: [1] }
- id: string_agg_on_T_by_k
  before:
  - create_tables
  sql: |
    select string_agg(s, ',' order by o) as a1 from T group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [string_agg(t.s, ',':Varchar order_by(t.o ASC))] }
      └─BatchHashAgg { group_key: [t.k], aggs: [string_agg(t.s, ',':Varchar order_by(t.o ASC))] }
        └─BatchExchange { order: [], dist: HashShard(t.k) }
          └─BatchProject { exprs: [t.k, t.s, ',':Varchar, t.o] }
            └─BatchScan { table: t, columns: [t.k, t.o, t.s], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1, t.k(hidden)], pk_columns: [t.k], pk_conflict: "no check" }
    └─StreamProject { exprs: [string_agg(t.s, ',':Varchar order_by(t.o ASC)), t.k] }
      └─StreamHashAgg { group_key: [t.k], aggs: [string_agg(t.s, ',':Varchar order_by(t.o ASC)), count] }
        └─StreamExchange { dist: HashShard(t.k) }
          └─StreamProject { exprs: [t.k, t.s, ',':Varchar, t.o, t._row_id] }
            └─StreamTableScan { table: t, columns: [t.k, t.o, t.s, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |
    Fragment 0
      StreamMaterialize { columns: [a1, t.k(hidden)], pk_columns: [t.k], pk_conflict: "no check" }
          materialized table: 4294967294
        StreamProject { exprs: [string_agg(t.s, ',':Varchar order_by(t.o ASC)), t.k] }
          StreamHashAgg { group_key: [t.k], aggs: [string_agg(t.s, ',':Varchar order_by(t.o ASC)), count] }
              result table: 1, state tables: [0]
            StreamExchange Hash([0]) from 1

    Fragment 1
      StreamProject { exprs: [t.k, t.s, ',':Varchar, t.o, t._row_id] }
        Chain { table: t, columns: [t.k, t.o, t.s, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
          Upstream
          BatchPlanNode

     Table 0 { columns: [t_k, t_o, t__row_id, t_s, ',':Varchar], primary key: [$0 ASC, $1 ASC, $2 ASC], value indices: [1, 2, 3, 4], distribution key: [0] }
     Table 1 { columns: [t_k, string_agg(t_s, ',':Varchar order_by(t_o ASC)), count], primary key: [$0 ASC], value indices: [1, 2], distribution key: [0] }
     Table 4294967294 { columns: [a1, t.k], primary key: [$1 ASC], value indices: [0, 1], distribution key: [1] }
- id: string_agg_on_Tk_by_k
  before:
  - create_tables
  sql: |
    select string_agg(s, ',' order by o) as a1 from Tk group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [string_agg(tk.s, ',':Varchar order_by(tk.o ASC))] }
      └─BatchSortAgg { group_key: [tk.k], aggs: [string_agg(tk.s, ',':Varchar order_by(tk.o ASC))] }
        └─BatchProject { exprs: [tk.k, tk.s, ',':Varchar, tk.o] }
          └─BatchScan { table: tk, columns: [tk.k, tk.o, tk.s], distribution: UpstreamHashShard(tk.k) }
  stream_plan: |
    StreamMaterialize { columns: [a1, tk.k(hidden)], pk_columns: [tk.k], pk_conflict: "no check" }
    └─StreamProject { exprs: [string_agg(tk.s, ',':Varchar order_by(tk.o ASC)), tk.k] }
      └─StreamHashAgg { group_key: [tk.k], aggs: [string_agg(tk.s, ',':Varchar order_by(tk.o ASC)), count] }
        └─StreamProject { exprs: [tk.k, tk.s, ',':Varchar, tk.o, tk.t._row_id] }
          └─StreamTableScan { table: tk, columns: [tk.k, tk.o, tk.s, tk.t._row_id], pk: [tk.t._row_id], dist: UpstreamHashShard(tk.k) }
  stream_dist_plan: |
    Fragment 0
      StreamMaterialize { columns: [a1, tk.k(hidden)], pk_columns: [tk.k], pk_conflict: "no check" }
          materialized table: 4294967294
        StreamProject { exprs: [string_agg(tk.s, ',':Varchar order_by(tk.o ASC)), tk.k] }
          StreamHashAgg { group_key: [tk.k], aggs: [string_agg(tk.s, ',':Varchar order_by(tk.o ASC)), count] }
              result table: 1, state tables: [0]
            StreamProject { exprs: [tk.k, tk.s, ',':Varchar, tk.o, tk.t._row_id] }
              Chain { table: tk, columns: [tk.k, tk.o, tk.s, tk.t._row_id], pk: [tk.t._row_id], dist: UpstreamHashShard(tk.k) }
                Upstream
                BatchPlanNode

     Table 0 { columns: [tk_k, tk_o, tk_t__row_id, tk_s, ',':Varchar], primary key: [$0 ASC, $1 ASC, $2 ASC], value indices: [1, 2, 3, 4], distribution key: [0] }
     Table 1 { columns: [tk_k, string_agg(tk_s, ',':Varchar order_by(tk_o ASC)), count], primary key: [$0 ASC], value indices: [1, 2], distribution key: [0] }
     Table 4294967294 { columns: [a1, tk.k], primary key: [$1 ASC], value indices: [0, 1], distribution key: [1] }
- id: string_agg_on_S_by_k
  before:
  - create_tables
  sql: |
    select string_agg(s, ',' order by o) as a1 from S group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [string_agg(s.s, ',':Varchar order_by(s.o ASC))] }
      └─BatchHashAgg { group_key: [s.k], aggs: [string_agg(s.s, ',':Varchar order_by(s.o ASC))] }
        └─BatchExchange { order: [], dist: HashShard(s.k) }
          └─BatchProject { exprs: [s.k, s.s, ',':Varchar, s.o] }
            └─BatchScan { table: s, columns: [s.k, s.o, s.s], distribution: Single }
  stream_plan: |
    StreamMaterialize { columns: [a1, s.k(hidden)], pk_columns: [s.k], pk_conflict: "no check" }
    └─StreamProject { exprs: [string_agg(s.s, ',':Varchar order_by(s.o ASC)), s.k] }
      └─StreamHashAgg { group_key: [s.k], aggs: [string_agg(s.s, ',':Varchar order_by(s.o ASC)), count] }
        └─StreamExchange { dist: HashShard(s.k) }
          └─StreamProject { exprs: [s.k, s.s, ',':Varchar, s.o, s.t._row_id] }
            └─StreamTableScan { table: s, columns: [s.k, s.o, s.s, s.t._row_id], pk: [s.t._row_id], dist: Single }
  stream_dist_plan: |
    Fragment 0
      StreamMaterialize { columns: [a1, s.k(hidden)], pk_columns: [s.k], pk_conflict: "no check" }
          materialized table: 4294967294
        StreamProject { exprs: [string_agg(s.s, ',':Varchar order_by(s.o ASC)), s.k] }
          StreamHashAgg { group_key: [s.k], aggs: [string_agg(s.s, ',':Varchar order_by(s.o ASC)), count] }
              result table: 1, state tables: [0]
            StreamExchange Hash([0]) from 1

    Fragment 1
      StreamProject { exprs: [s.k, s.s, ',':Varchar, s.o, s.t._row_id] }
        Chain { table: s, columns: [s.k, s.o, s.s, s.t._row_id], pk: [s.t._row_id], dist: Single }
          Upstream
          BatchPlanNode

     Table 0 { columns: [s_k, s_o, s_t__row_id, s_s, ',':Varchar], primary key: [$0 ASC, $1 ASC, $2 ASC], value indices: [1, 2, 3, 4], distribution key: [0] }
     Table 1 { columns: [s_k, string_agg(s_s, ',':Varchar order_by(s_o ASC)), count], primary key: [$0 ASC], value indices: [1, 2], distribution key: [0] }
     Table 4294967294 { columns: [a1, s.k], primary key: [$1 ASC], value indices: [0, 1], distribution key: [1] }
- id: string_agg_on_AO_by_k
  before:
  - create_tables
  sql: |
    select string_agg(s, ',' order by o) as a1 from AO group by k;
  stream_plan: |
    StreamMaterialize { columns: [a1, ao.k(hidden)], pk_columns: [ao.k], pk_conflict: "no check" }
    └─StreamProject { exprs: [string_agg(ao.s, ',':Varchar order_by(ao.o ASC)), ao.k] }
      └─StreamAppendOnlyHashAgg { group_key: [ao.k], aggs: [string_agg(ao.s, ',':Varchar order_by(ao.o ASC)), count] }
        └─StreamExchange { dist: HashShard(ao.k) }
          └─StreamProject { exprs: [ao.k, ao.s, ',':Varchar, ao.o, ao._row_id] }
            └─StreamTableScan { table: ao, columns: [ao.k, ao.o, ao.s, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |
    Fragment 0
      StreamMaterialize { columns: [a1, ao.k(hidden)], pk_columns: [ao.k], pk_conflict: "no check" }
          materialized table: 4294967294
        StreamProject { exprs: [string_agg(ao.s, ',':Varchar order_by(ao.o ASC)), ao.k] }
          StreamAppendOnlyHashAgg { group_key: [ao.k], aggs: [string_agg(ao.s, ',':Varchar order_by(ao.o ASC)), count] }
              result table: 0, state tables: []
            StreamExchange Hash([0]) from 1

    Fragment 1
      StreamProject { exprs: [ao.k, ao.s, ',':Varchar, ao.o, ao._row_id] }
        Chain { table: ao, columns: [ao.k, ao.o, ao.s, ao._row_id], pk: [ao._row_id], dist: UpstreamHashShard(ao._row_id) }
          Upstream
          BatchPlanNode

     Table 0 { columns: [ao_k, string_agg(ao_s, ',':Varchar order_by(ao_o ASC)), count], primary key: [$0 ASC], value indices: [1, 2], distribution key: [0] }
     Table 4294967294 { columns: [a1, ao.k], primary key: [$1 ASC], value indices: [0, 1], distribution key: [1] }
