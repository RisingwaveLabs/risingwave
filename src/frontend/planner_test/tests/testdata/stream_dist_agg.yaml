# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- id: create_tables
  sql: |
    /* T: updatable; Tk: Hash(k) distribution; AO: append-only; S: single distribution */
    create table T  (k int, v int, o int, s varchar);
    create index Tk on T(k) include(k, v, o, s);
    create materialized view S as select * from T order by o limit 100;
    create table AO (k int, v int, o int, s varchar) with (appendonly = true);
- id: extreme_on_single
  before:
  - create_tables
  sql: |
    select max(v) as a1 from S;
  batch_plan: |
    BatchSimpleAgg { aggs: [max(max(s.v))] }
      BatchExchange { order: [], dist: Single }
        BatchSimpleAgg { aggs: [max(s.v)] }
          BatchScan { table: s, columns: [s.v], distribution: UpstreamHashShard() }
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [] }
      StreamProject { exprs: [max(s.v)] }
        StreamGlobalSimpleAgg { aggs: [count, max(s.v)] }
          StreamTableScan { table: s, columns: [s.v, s.o, s.t._row_id], pk: [s.t._row_id], distribution: Single }
  stream_dist_plan: |+
    Fragment 0
      StreamMaterialize { columns: [a1], pk_columns: [] }
       materialized table: 4294967294
       Output: [max(s.v)]
       Stream key: []
        StreamProject { exprs: [max(s.v)] }
         Output: [max(s.v)]
         Stream key: []
          StreamGlobalSimpleAgg { aggs: [count, max(s.v)] }
           state tables: [0, 1]
           Output: [count, max(s.v)]
           Stream key: []
            Chain { table: s, columns: [s.v, s.o, s.t._row_id], pk: [s.t._row_id], distribution: Single }
             Output: [s.v, s.o, s.t._row_id]
             Stream key: [s.t._row_id]
              Upstream
               Output: [k, v, o, s, t._row_id]
               Stream key: [t._row_id]
              BatchPlanNode
               Output: [s.v, s.o, s.t._row_id]
               Stream key: [s.t._row_id]
               AppendOnly

    Table 0
      columns: [count:bigint]
      primary key: []
      values indices: [0]

    Table 1
      columns: [s.v:integer, s.t._row_id:bigint]
      primary key: [$0 DESC, $1 ASC]
      values indices: [0, 1]

    Table 4294967294
      columns: [a1:integer]
      primary key: []
      values indices: [0]

- id: sum_on_single
  before:
  - create_tables
  sql: |
    select sum(v) as a1 from S;
  batch_plan: |
    BatchSimpleAgg { aggs: [sum(sum(s.v))] }
      BatchExchange { order: [], dist: Single }
        BatchSimpleAgg { aggs: [sum(s.v)] }
          BatchScan { table: s, columns: [s.v], distribution: UpstreamHashShard() }
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [] }
      StreamProject { exprs: [sum(s.v)] }
        StreamGlobalSimpleAgg { aggs: [count, sum(s.v)] }
          StreamTableScan { table: s, columns: [s.v, s.o, s.t._row_id], pk: [s.t._row_id], distribution: Single }
  stream_dist_plan: |+
    Fragment 0
      StreamMaterialize { columns: [a1], pk_columns: [] }
       materialized table: 4294967294
       Output: [sum(s.v)]
       Stream key: []
        StreamProject { exprs: [sum(s.v)] }
         Output: [sum(s.v)]
         Stream key: []
          StreamGlobalSimpleAgg { aggs: [count, sum(s.v)] }
           state tables: [0, 1]
           Output: [count, sum(s.v)]
           Stream key: []
            Chain { table: s, columns: [s.v, s.o, s.t._row_id], pk: [s.t._row_id], distribution: Single }
             Output: [s.v, s.o, s.t._row_id]
             Stream key: [s.t._row_id]
              Upstream
               Output: [k, v, o, s, t._row_id]
               Stream key: [t._row_id]
              BatchPlanNode
               Output: [s.v, s.o, s.t._row_id]
               Stream key: [s.t._row_id]
               AppendOnly

    Table 0
      columns: [count:bigint]
      primary key: []
      values indices: [0]

    Table 1
      columns: [sum(s.v):bigint]
      primary key: []
      values indices: [0]

    Table 4294967294
      columns: [a1:bigint]
      primary key: []
      values indices: [0]

- id: cnt_on_single
  before:
  - create_tables
  sql: |
    select count(v) as a1 from S;
  batch_plan: |
    BatchSimpleAgg { aggs: [sum(count(s.v))] }
      BatchExchange { order: [], dist: Single }
        BatchSimpleAgg { aggs: [count(s.v)] }
          BatchScan { table: s, columns: [s.v], distribution: UpstreamHashShard() }
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [] }
      StreamProject { exprs: [count(s.v)] }
        StreamGlobalSimpleAgg { aggs: [count, count(s.v)] }
          StreamTableScan { table: s, columns: [s.v, s.o, s.t._row_id], pk: [s.t._row_id], distribution: Single }
  stream_dist_plan: |+
    Fragment 0
      StreamMaterialize { columns: [a1], pk_columns: [] }
       materialized table: 4294967294
       Output: [count(s.v)]
       Stream key: []
        StreamProject { exprs: [count(s.v)] }
         Output: [count(s.v)]
         Stream key: []
          StreamGlobalSimpleAgg { aggs: [count, count(s.v)] }
           state tables: [0, 1]
           Output: [count, count(s.v)]
           Stream key: []
            Chain { table: s, columns: [s.v, s.o, s.t._row_id], pk: [s.t._row_id], distribution: Single }
             Output: [s.v, s.o, s.t._row_id]
             Stream key: [s.t._row_id]
              Upstream
               Output: [k, v, o, s, t._row_id]
               Stream key: [t._row_id]
              BatchPlanNode
               Output: [s.v, s.o, s.t._row_id]
               Stream key: [s.t._row_id]
               AppendOnly

    Table 0
      columns: [count:bigint]
      primary key: []
      values indices: [0]

    Table 1
      columns: [count(s.v):bigint]
      primary key: []
      values indices: [0]

    Table 4294967294
      columns: [a1:bigint]
      primary key: []
      values indices: [0]

- id: string_agg_on_single
  before:
  - create_tables
  sql: |
    select string_agg(s, ',' order by v) as a1 from S;
  batch_plan: |
    BatchSimpleAgg { aggs: [string_agg(s.s, ',':Varchar order_by(s.v ASC NULLS LAST))] }
      BatchExchange { order: [], dist: Single }
        BatchProject { exprs: [s.s, ',':Varchar, s.v] }
          BatchScan { table: s, columns: [s.v, s.s], distribution: UpstreamHashShard() }
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [] }
      StreamProject { exprs: [string_agg(s.s, ',':Varchar order_by(s.v ASC NULLS LAST))] }
        StreamGlobalSimpleAgg { aggs: [count, string_agg(s.s, ',':Varchar order_by(s.v ASC NULLS LAST))] }
          StreamProject { exprs: [s.s, ',':Varchar, s.v, s.t._row_id] }
            StreamTableScan { table: s, columns: [s.v, s.s, s.o, s.t._row_id], pk: [s.t._row_id], distribution: Single }
  stream_dist_plan: |+
    Fragment 0
      StreamMaterialize { columns: [a1], pk_columns: [] }
       materialized table: 4294967294
       Output: [string_agg(s.s, ',':Varchar order_by(s.v ASC NULLS LAST))]
       Stream key: []
        StreamProject { exprs: [string_agg(s.s, ',':Varchar order_by(s.v ASC NULLS LAST))] }
         Output: [string_agg(s.s, ',':Varchar order_by(s.v ASC NULLS LAST))]
         Stream key: []
          StreamGlobalSimpleAgg { aggs: [count, string_agg(s.s, ',':Varchar order_by(s.v ASC NULLS LAST))] }
           state tables: [0, 1]
           Output: [count, string_agg(s.s, ',':Varchar order_by(s.v ASC NULLS LAST))]
           Stream key: []
            StreamProject { exprs: [s.s, ',':Varchar, s.v, s.t._row_id] }
             Output: [s.s, ',':Varchar, s.v, s.t._row_id]
             Stream key: [s.t._row_id]
              Chain { table: s, columns: [s.v, s.s, s.o, s.t._row_id], pk: [s.t._row_id], distribution: Single }
               Output: [s.v, s.s, s.o, s.t._row_id]
               Stream key: [s.t._row_id]
                Upstream
                 Output: [k, v, o, s, t._row_id]
                 Stream key: [t._row_id]
                BatchPlanNode
                 Output: [s.v, s.s, s.o, s.t._row_id]
                 Stream key: [s.t._row_id]
                 AppendOnly

    Table 0
      columns: [count:bigint]
      primary key: []
      values indices: [0]

    Table 1
      columns: [s.v:integer, s.t._row_id:bigint, s.s:varchar, ',':Varchar:varchar]
      primary key: [$0 ASC, $1 ASC]
      values indices: [0, 1, 2, 3]

    Table 4294967294
      columns: [a1:varchar]
      primary key: []
      values indices: [0]

- id: extreme_on_T
  before:
  - create_tables
  sql: |
    select max(v) as a1 from T;
  batch_plan: |
    BatchSimpleAgg { aggs: [max(max(t.v))] }
      BatchExchange { order: [], dist: Single }
        BatchSimpleAgg { aggs: [max(t.v)] }
          BatchScan { table: t, columns: [t.v], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [] }
      StreamProject { exprs: [max(max(t.v))] }
        StreamGlobalSimpleAgg { aggs: [sum(count), max(max(t.v))] }
          StreamExchange { dist: Single }
            StreamHashAgg { group_key: [Vnode(t._row_id)], aggs: [count, max(t.v)] }
              StreamProject { exprs: [t.v, t._row_id, Vnode(t._row_id)] }
                StreamTableScan { table: t, columns: [t.v, t._row_id], pk: [t._row_id], distribution: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |+
    Fragment 0
      StreamMaterialize { columns: [a1], pk_columns: [] }
       materialized table: 4294967294
       Output: [max(max(t.v))]
       Stream key: []
        StreamProject { exprs: [max(max(t.v))] }
         Output: [max(max(t.v))]
         Stream key: []
          StreamGlobalSimpleAgg { aggs: [sum(count), max(max(t.v))] }
           state tables: [0, 1]
           Output: [sum(count), max(max(t.v))]
           Stream key: []
            StreamExchange Single from 1
             Output: [Vnode(t._row_id), count, max(t.v)]
             Stream key: [Vnode(t._row_id)]

    Fragment 1
      StreamHashAgg { group_key: [Vnode(t._row_id)], aggs: [count, max(t.v)] }
       state tables: [2, 3]
       Output: [Vnode(t._row_id), count, max(t.v)]
       Stream key: [Vnode(t._row_id)]
        StreamProject { exprs: [t.v, t._row_id, Vnode(t._row_id)] }
         Output: [t.v, t._row_id, Vnode(t._row_id)]
         Stream key: [t._row_id]
          Chain { table: t, columns: [t.v, t._row_id], pk: [t._row_id], distribution: UpstreamHashShard(t._row_id) }
           Output: [t.v, t._row_id]
           Stream key: [t._row_id]
            Upstream
             Output: [k, v, o, s, _row_id]
             Stream key: [_row_id]
            BatchPlanNode
             Output: [t.v, t._row_id]
             Stream key: [t._row_id]
             AppendOnly

    Table 0
      columns: [sum(count):bigint]
      primary key: []
      values indices: [0]

    Table 1
      columns: [max(t.v):integer, Vnode(t._row_id):smallint]
      primary key: [$0 DESC, $1 ASC]
      values indices: [0, 1]

    Table 2
      columns: [Vnode(t._row_id):smallint, count:bigint]
      primary key: [$0 ASC]
      values indices: [0, 1]

    Table 3
      columns: [Vnode(t._row_id):smallint, t.v:integer, t._row_id:bigint]
      primary key: [$0 ASC, $1 DESC, $2 ASC]
      values indices: [0, 1, 2]
      vnode column idx: 0

    Table 4294967294
      columns: [a1:integer]
      primary key: []
      values indices: [0]

- id: extreme_on_AO
  before:
  - create_tables
  sql: |
    select max(v) as a1 from AO;
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [] }
      StreamProject { exprs: [max(max(ao.v))] }
        StreamAppendOnlyGlobalSimpleAgg { aggs: [sum(count), max(max(ao.v))] }
          StreamExchange { dist: Single }
            StreamStatelessLocalSimpleAgg { aggs: [count, max(ao.v)] }
              StreamTableScan { table: ao, columns: [ao.v, ao._row_id], pk: [ao._row_id], distribution: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |+
    Fragment 0
      StreamMaterialize { columns: [a1], pk_columns: [] }
       materialized table: 4294967294
       Output: [max(max(ao.v))]
       Stream key: []
        StreamProject { exprs: [max(max(ao.v))] }
         Output: [max(max(ao.v))]
         Stream key: []
          StreamAppendOnlyGlobalSimpleAgg { aggs: [sum(count), max(max(ao.v))] }
           state tables: [0, 1]
           Output: [sum(count), max(max(ao.v))]
           Stream key: []
            StreamExchange Single from 1
             Output: [count, max(ao.v)]
             Stream key: []
             AppendOnly

    Fragment 1
      StreamStatelessLocalSimpleAgg { aggs: [count, max(ao.v)] }
       Output: [count, max(ao.v)]
       Stream key: []
       AppendOnly
        Chain { table: ao, columns: [ao.v, ao._row_id], pk: [ao._row_id], distribution: UpstreamHashShard(ao._row_id) }
         Output: [ao.v, ao._row_id]
         Stream key: [ao._row_id]
         AppendOnly
          Upstream
           Output: [k, v, o, s, _row_id]
           Stream key: [_row_id]
          BatchPlanNode
           Output: [ao.v, ao._row_id]
           Stream key: [ao._row_id]
           AppendOnly

    Table 0
      columns: [sum(count):bigint]
      primary key: []
      values indices: [0]

    Table 1
      columns: [max(max(ao.v)):integer]
      primary key: []
      values indices: [0]

    Table 4294967294
      columns: [a1:integer]
      primary key: []
      values indices: [0]

- id: sum_on_T
  before:
  - create_tables
  sql: |
    select sum(v) as a1 from T;
  batch_plan: |
    BatchSimpleAgg { aggs: [sum(sum(t.v))] }
      BatchExchange { order: [], dist: Single }
        BatchSimpleAgg { aggs: [sum(t.v)] }
          BatchScan { table: t, columns: [t.v], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [] }
      StreamProject { exprs: [sum(sum(t.v))] }
        StreamGlobalSimpleAgg { aggs: [sum(count), sum(sum(t.v))] }
          StreamExchange { dist: Single }
            StreamStatelessLocalSimpleAgg { aggs: [count, sum(t.v)] }
              StreamTableScan { table: t, columns: [t.v, t._row_id], pk: [t._row_id], distribution: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |+
    Fragment 0
      StreamMaterialize { columns: [a1], pk_columns: [] }
       materialized table: 4294967294
       Output: [sum(sum(t.v))]
       Stream key: []
        StreamProject { exprs: [sum(sum(t.v))] }
         Output: [sum(sum(t.v))]
         Stream key: []
          StreamGlobalSimpleAgg { aggs: [sum(count), sum(sum(t.v))] }
           state tables: [0, 1]
           Output: [sum(count), sum(sum(t.v))]
           Stream key: []
            StreamExchange Single from 1
             Output: [count, sum(t.v)]
             Stream key: []

    Fragment 1
      StreamStatelessLocalSimpleAgg { aggs: [count, sum(t.v)] }
       Output: [count, sum(t.v)]
       Stream key: []
        Chain { table: t, columns: [t.v, t._row_id], pk: [t._row_id], distribution: UpstreamHashShard(t._row_id) }
         Output: [t.v, t._row_id]
         Stream key: [t._row_id]
          Upstream
           Output: [k, v, o, s, _row_id]
           Stream key: [_row_id]
          BatchPlanNode
           Output: [t.v, t._row_id]
           Stream key: [t._row_id]
           AppendOnly

    Table 0
      columns: [sum(count):bigint]
      primary key: []
      values indices: [0]

    Table 1
      columns: [sum(sum(t.v)):bigint]
      primary key: []
      values indices: [0]

    Table 4294967294
      columns: [a1:bigint]
      primary key: []
      values indices: [0]

- id: sum_on_AO
  before:
  - create_tables
  sql: |
    select sum(v) as a1 from AO;
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [] }
      StreamProject { exprs: [sum(sum(ao.v))] }
        StreamAppendOnlyGlobalSimpleAgg { aggs: [sum(count), sum(sum(ao.v))] }
          StreamExchange { dist: Single }
            StreamStatelessLocalSimpleAgg { aggs: [count, sum(ao.v)] }
              StreamTableScan { table: ao, columns: [ao.v, ao._row_id], pk: [ao._row_id], distribution: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |+
    Fragment 0
      StreamMaterialize { columns: [a1], pk_columns: [] }
       materialized table: 4294967294
       Output: [sum(sum(ao.v))]
       Stream key: []
        StreamProject { exprs: [sum(sum(ao.v))] }
         Output: [sum(sum(ao.v))]
         Stream key: []
          StreamAppendOnlyGlobalSimpleAgg { aggs: [sum(count), sum(sum(ao.v))] }
           state tables: [0, 1]
           Output: [sum(count), sum(sum(ao.v))]
           Stream key: []
            StreamExchange Single from 1
             Output: [count, sum(ao.v)]
             Stream key: []
             AppendOnly

    Fragment 1
      StreamStatelessLocalSimpleAgg { aggs: [count, sum(ao.v)] }
       Output: [count, sum(ao.v)]
       Stream key: []
       AppendOnly
        Chain { table: ao, columns: [ao.v, ao._row_id], pk: [ao._row_id], distribution: UpstreamHashShard(ao._row_id) }
         Output: [ao.v, ao._row_id]
         Stream key: [ao._row_id]
         AppendOnly
          Upstream
           Output: [k, v, o, s, _row_id]
           Stream key: [_row_id]
          BatchPlanNode
           Output: [ao.v, ao._row_id]
           Stream key: [ao._row_id]
           AppendOnly

    Table 0
      columns: [sum(count):bigint]
      primary key: []
      values indices: [0]

    Table 1
      columns: [sum(sum(ao.v)):bigint]
      primary key: []
      values indices: [0]

    Table 4294967294
      columns: [a1:bigint]
      primary key: []
      values indices: [0]

- id: cnt_on_T
  before:
  - create_tables
  sql: |
    select count(v) as a1 from T;
  batch_plan: |
    BatchSimpleAgg { aggs: [sum(count(t.v))] }
      BatchExchange { order: [], dist: Single }
        BatchSimpleAgg { aggs: [count(t.v)] }
          BatchScan { table: t, columns: [t.v], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [] }
      StreamProject { exprs: [sum(count(t.v))] }
        StreamGlobalSimpleAgg { aggs: [sum(count), sum(count(t.v))] }
          StreamExchange { dist: Single }
            StreamStatelessLocalSimpleAgg { aggs: [count, count(t.v)] }
              StreamTableScan { table: t, columns: [t.v, t._row_id], pk: [t._row_id], distribution: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |+
    Fragment 0
      StreamMaterialize { columns: [a1], pk_columns: [] }
       materialized table: 4294967294
       Output: [sum(count(t.v))]
       Stream key: []
        StreamProject { exprs: [sum(count(t.v))] }
         Output: [sum(count(t.v))]
         Stream key: []
          StreamGlobalSimpleAgg { aggs: [sum(count), sum(count(t.v))] }
           state tables: [0, 1]
           Output: [sum(count), sum(count(t.v))]
           Stream key: []
            StreamExchange Single from 1
             Output: [count, count(t.v)]
             Stream key: []

    Fragment 1
      StreamStatelessLocalSimpleAgg { aggs: [count, count(t.v)] }
       Output: [count, count(t.v)]
       Stream key: []
        Chain { table: t, columns: [t.v, t._row_id], pk: [t._row_id], distribution: UpstreamHashShard(t._row_id) }
         Output: [t.v, t._row_id]
         Stream key: [t._row_id]
          Upstream
           Output: [k, v, o, s, _row_id]
           Stream key: [_row_id]
          BatchPlanNode
           Output: [t.v, t._row_id]
           Stream key: [t._row_id]
           AppendOnly

    Table 0
      columns: [sum(count):bigint]
      primary key: []
      values indices: [0]

    Table 1
      columns: [sum(count(t.v)):bigint]
      primary key: []
      values indices: [0]

    Table 4294967294
      columns: [a1:bigint]
      primary key: []
      values indices: [0]

- id: cnt_on_AO
  before:
  - create_tables
  sql: |
    select count(v) as a1 from AO;
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [] }
      StreamProject { exprs: [sum(count(ao.v))] }
        StreamAppendOnlyGlobalSimpleAgg { aggs: [sum(count), sum(count(ao.v))] }
          StreamExchange { dist: Single }
            StreamStatelessLocalSimpleAgg { aggs: [count, count(ao.v)] }
              StreamTableScan { table: ao, columns: [ao.v, ao._row_id], pk: [ao._row_id], distribution: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |+
    Fragment 0
      StreamMaterialize { columns: [a1], pk_columns: [] }
       materialized table: 4294967294
       Output: [sum(count(ao.v))]
       Stream key: []
        StreamProject { exprs: [sum(count(ao.v))] }
         Output: [sum(count(ao.v))]
         Stream key: []
          StreamAppendOnlyGlobalSimpleAgg { aggs: [sum(count), sum(count(ao.v))] }
           state tables: [0, 1]
           Output: [sum(count), sum(count(ao.v))]
           Stream key: []
            StreamExchange Single from 1
             Output: [count, count(ao.v)]
             Stream key: []
             AppendOnly

    Fragment 1
      StreamStatelessLocalSimpleAgg { aggs: [count, count(ao.v)] }
       Output: [count, count(ao.v)]
       Stream key: []
       AppendOnly
        Chain { table: ao, columns: [ao.v, ao._row_id], pk: [ao._row_id], distribution: UpstreamHashShard(ao._row_id) }
         Output: [ao.v, ao._row_id]
         Stream key: [ao._row_id]
         AppendOnly
          Upstream
           Output: [k, v, o, s, _row_id]
           Stream key: [_row_id]
          BatchPlanNode
           Output: [ao.v, ao._row_id]
           Stream key: [ao._row_id]
           AppendOnly

    Table 0
      columns: [sum(count):bigint]
      primary key: []
      values indices: [0]

    Table 1
      columns: [sum(count(ao.v)):bigint]
      primary key: []
      values indices: [0]

    Table 4294967294
      columns: [a1:bigint]
      primary key: []
      values indices: [0]

- id: string_agg_on_T
  before:
  - create_tables
  sql: |
    select string_agg(s, ',' order by o) as a1 from T;
  batch_plan: |
    BatchSimpleAgg { aggs: [string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))] }
      BatchExchange { order: [], dist: Single }
        BatchProject { exprs: [t.s, ',':Varchar, t.o] }
          BatchScan { table: t, columns: [t.o, t.s], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [] }
      StreamProject { exprs: [string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))] }
        StreamGlobalSimpleAgg { aggs: [count, string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))] }
          StreamExchange { dist: Single }
            StreamProject { exprs: [t.s, ',':Varchar, t.o, t._row_id] }
              StreamTableScan { table: t, columns: [t.o, t.s, t._row_id], pk: [t._row_id], distribution: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |+
    Fragment 0
      StreamMaterialize { columns: [a1], pk_columns: [] }
       materialized table: 4294967294
       Output: [string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))]
       Stream key: []
        StreamProject { exprs: [string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))] }
         Output: [string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))]
         Stream key: []
          StreamGlobalSimpleAgg { aggs: [count, string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))] }
           state tables: [0, 1]
           Output: [count, string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))]
           Stream key: []
            StreamExchange Single from 1
             Output: [t.s, ',':Varchar, t.o, t._row_id]
             Stream key: [t._row_id]

    Fragment 1
      StreamProject { exprs: [t.s, ',':Varchar, t.o, t._row_id] }
       Output: [t.s, ',':Varchar, t.o, t._row_id]
       Stream key: [t._row_id]
        Chain { table: t, columns: [t.o, t.s, t._row_id], pk: [t._row_id], distribution: UpstreamHashShard(t._row_id) }
         Output: [t.o, t.s, t._row_id]
         Stream key: [t._row_id]
          Upstream
           Output: [k, v, o, s, _row_id]
           Stream key: [_row_id]
          BatchPlanNode
           Output: [t.o, t.s, t._row_id]
           Stream key: [t._row_id]
           AppendOnly

    Table 0
      columns: [count:bigint]
      primary key: []
      values indices: [0]

    Table 1
      columns: [t.o:integer, t._row_id:bigint, t.s:varchar, ',':Varchar:varchar]
      primary key: [$0 ASC, $1 ASC]
      values indices: [0, 1, 2, 3]

    Table 4294967294
      columns: [a1:varchar]
      primary key: []
      values indices: [0]

- id: string_agg_on_AO
  before:
  - create_tables
  sql: |
    select string_agg(s, ',' order by o) as a1 from AO;
  stream_plan: |
    StreamMaterialize { columns: [a1], pk_columns: [] }
      StreamProject { exprs: [string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST))] }
        StreamAppendOnlyGlobalSimpleAgg { aggs: [count, string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST))] }
          StreamExchange { dist: Single }
            StreamProject { exprs: [ao.s, ',':Varchar, ao.o, ao._row_id] }
              StreamTableScan { table: ao, columns: [ao.o, ao.s, ao._row_id], pk: [ao._row_id], distribution: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |+
    Fragment 0
      StreamMaterialize { columns: [a1], pk_columns: [] }
       materialized table: 4294967294
       Output: [string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST))]
       Stream key: []
        StreamProject { exprs: [string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST))] }
         Output: [string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST))]
         Stream key: []
          StreamAppendOnlyGlobalSimpleAgg { aggs: [count, string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST))] }
           state tables: [0, 1]
           Output: [count, string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST))]
           Stream key: []
            StreamExchange Single from 1
             Output: [ao.s, ',':Varchar, ao.o, ao._row_id]
             Stream key: [ao._row_id]
             AppendOnly

    Fragment 1
      StreamProject { exprs: [ao.s, ',':Varchar, ao.o, ao._row_id] }
       Output: [ao.s, ',':Varchar, ao.o, ao._row_id]
       Stream key: [ao._row_id]
       AppendOnly
        Chain { table: ao, columns: [ao.o, ao.s, ao._row_id], pk: [ao._row_id], distribution: UpstreamHashShard(ao._row_id) }
         Output: [ao.o, ao.s, ao._row_id]
         Stream key: [ao._row_id]
         AppendOnly
          Upstream
           Output: [k, v, o, s, _row_id]
           Stream key: [_row_id]
          BatchPlanNode
           Output: [ao.o, ao.s, ao._row_id]
           Stream key: [ao._row_id]
           AppendOnly

    Table 0
      columns: [count:bigint]
      primary key: []
      values indices: [0]

    Table 1
      columns: [string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST)):varchar]
      primary key: []
      values indices: [0]

    Table 4294967294
      columns: [a1:varchar]
      primary key: []
      values indices: [0]

- id: extreme_count_on_T
  before:
  - create_tables
  sql: |
    select max(v) as a1, count(v) as a2 from T;
  batch_plan: |
    BatchSimpleAgg { aggs: [max(max(t.v)), sum(count(t.v))] }
      BatchExchange { order: [], dist: Single }
        BatchSimpleAgg { aggs: [max(t.v), count(t.v)] }
          BatchScan { table: t, columns: [t.v], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1, a2], pk_columns: [] }
      StreamProject { exprs: [max(max(t.v)), sum(count(t.v))] }
        StreamGlobalSimpleAgg { aggs: [sum(count), max(max(t.v)), sum(count(t.v))] }
          StreamExchange { dist: Single }
            StreamHashAgg { group_key: [Vnode(t._row_id)], aggs: [count, max(t.v), count(t.v)] }
              StreamProject { exprs: [t.v, t._row_id, Vnode(t._row_id)] }
                StreamTableScan { table: t, columns: [t.v, t._row_id], pk: [t._row_id], distribution: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |+
    Fragment 0
      StreamMaterialize { columns: [a1, a2], pk_columns: [] }
       materialized table: 4294967294
       Output: [max(max(t.v)), sum(count(t.v))]
       Stream key: []
        StreamProject { exprs: [max(max(t.v)), sum(count(t.v))] }
         Output: [max(max(t.v)), sum(count(t.v))]
         Stream key: []
          StreamGlobalSimpleAgg { aggs: [sum(count), max(max(t.v)), sum(count(t.v))] }
           state tables: [0, 1, 2]
           Output: [sum(count), max(max(t.v)), sum(count(t.v))]
           Stream key: []
            StreamExchange Single from 1
             Output: [Vnode(t._row_id), count, max(t.v), count(t.v)]
             Stream key: [Vnode(t._row_id)]

    Fragment 1
      StreamHashAgg { group_key: [Vnode(t._row_id)], aggs: [count, max(t.v), count(t.v)] }
       state tables: [3, 4, 5]
       Output: [Vnode(t._row_id), count, max(t.v), count(t.v)]
       Stream key: [Vnode(t._row_id)]
        StreamProject { exprs: [t.v, t._row_id, Vnode(t._row_id)] }
         Output: [t.v, t._row_id, Vnode(t._row_id)]
         Stream key: [t._row_id]
          Chain { table: t, columns: [t.v, t._row_id], pk: [t._row_id], distribution: UpstreamHashShard(t._row_id) }
           Output: [t.v, t._row_id]
           Stream key: [t._row_id]
            Upstream
             Output: [k, v, o, s, _row_id]
             Stream key: [_row_id]
            BatchPlanNode
             Output: [t.v, t._row_id]
             Stream key: [t._row_id]
             AppendOnly

    Table 0
      columns: [sum(count):bigint]
      primary key: []
      values indices: [0]

    Table 1
      columns: [max(t.v):integer, Vnode(t._row_id):smallint]
      primary key: [$0 DESC, $1 ASC]
      values indices: [0, 1]

    Table 2
      columns: [sum(count(t.v)):bigint]
      primary key: []
      values indices: [0]

    Table 3
      columns: [Vnode(t._row_id):smallint, count:bigint]
      primary key: [$0 ASC]
      values indices: [0, 1]

    Table 4
      columns: [Vnode(t._row_id):smallint, t.v:integer, t._row_id:bigint]
      primary key: [$0 ASC, $1 DESC, $2 ASC]
      values indices: [0, 1, 2]
      vnode column idx: 0

    Table 5
      columns: [Vnode(t._row_id):smallint, count(t.v):bigint]
      primary key: [$0 ASC]
      values indices: [0, 1]

    Table 4294967294
      columns: [a1:integer, a2:bigint]
      primary key: []
      values indices: [0, 1]

- id: extreme_count_on_AO
  before:
  - create_tables
  sql: |
    select max(v) as a1, count(v) as a2 from AO;
  stream_plan: |
    StreamMaterialize { columns: [a1, a2], pk_columns: [] }
      StreamProject { exprs: [max(max(ao.v)), sum(count(ao.v))] }
        StreamAppendOnlyGlobalSimpleAgg { aggs: [sum(count), max(max(ao.v)), sum(count(ao.v))] }
          StreamExchange { dist: Single }
            StreamStatelessLocalSimpleAgg { aggs: [count, max(ao.v), count(ao.v)] }
              StreamTableScan { table: ao, columns: [ao.v, ao._row_id], pk: [ao._row_id], distribution: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |+
    Fragment 0
      StreamMaterialize { columns: [a1, a2], pk_columns: [] }
       materialized table: 4294967294
       Output: [max(max(ao.v)), sum(count(ao.v))]
       Stream key: []
        StreamProject { exprs: [max(max(ao.v)), sum(count(ao.v))] }
         Output: [max(max(ao.v)), sum(count(ao.v))]
         Stream key: []
          StreamAppendOnlyGlobalSimpleAgg { aggs: [sum(count), max(max(ao.v)), sum(count(ao.v))] }
           state tables: [0, 1, 2]
           Output: [sum(count), max(max(ao.v)), sum(count(ao.v))]
           Stream key: []
            StreamExchange Single from 1
             Output: [count, max(ao.v), count(ao.v)]
             Stream key: []
             AppendOnly

    Fragment 1
      StreamStatelessLocalSimpleAgg { aggs: [count, max(ao.v), count(ao.v)] }
       Output: [count, max(ao.v), count(ao.v)]
       Stream key: []
       AppendOnly
        Chain { table: ao, columns: [ao.v, ao._row_id], pk: [ao._row_id], distribution: UpstreamHashShard(ao._row_id) }
         Output: [ao.v, ao._row_id]
         Stream key: [ao._row_id]
         AppendOnly
          Upstream
           Output: [k, v, o, s, _row_id]
           Stream key: [_row_id]
          BatchPlanNode
           Output: [ao.v, ao._row_id]
           Stream key: [ao._row_id]
           AppendOnly

    Table 0
      columns: [sum(count):bigint]
      primary key: []
      values indices: [0]

    Table 1
      columns: [max(max(ao.v)):integer]
      primary key: []
      values indices: [0]

    Table 2
      columns: [sum(count(ao.v)):bigint]
      primary key: []
      values indices: [0]

    Table 4294967294
      columns: [a1:integer, a2:bigint]
      primary key: []
      values indices: [0, 1]

- id: count_string_agg_on_T
  before:
  - create_tables
  sql: |
    select count(v) as a1, string_agg(s, ',' order by o) as a2 from T;
  batch_plan: |
    BatchSimpleAgg { aggs: [count(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))] }
      BatchExchange { order: [], dist: Single }
        BatchProject { exprs: [t.v, t.s, ',':Varchar, t.o] }
          BatchScan { table: t, columns: [t.v, t.o, t.s], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1, a2], pk_columns: [] }
      StreamProject { exprs: [count(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))] }
        StreamGlobalSimpleAgg { aggs: [count, count(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))] }
          StreamExchange { dist: Single }
            StreamProject { exprs: [t.v, t.s, ',':Varchar, t.o, t._row_id] }
              StreamTableScan { table: t, columns: [t.v, t.o, t.s, t._row_id], pk: [t._row_id], distribution: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |+
    Fragment 0
      StreamMaterialize { columns: [a1, a2], pk_columns: [] }
       materialized table: 4294967294
       Output: [count(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))]
       Stream key: []
        StreamProject { exprs: [count(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))] }
         Output: [count(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))]
         Stream key: []
          StreamGlobalSimpleAgg { aggs: [count, count(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))] }
           state tables: [0, 1, 2]
           Output: [count, count(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))]
           Stream key: []
            StreamExchange Single from 1
             Output: [t.v, t.s, ',':Varchar, t.o, t._row_id]
             Stream key: [t._row_id]

    Fragment 1
      StreamProject { exprs: [t.v, t.s, ',':Varchar, t.o, t._row_id] }
       Output: [t.v, t.s, ',':Varchar, t.o, t._row_id]
       Stream key: [t._row_id]
        Chain { table: t, columns: [t.v, t.o, t.s, t._row_id], pk: [t._row_id], distribution: UpstreamHashShard(t._row_id) }
         Output: [t.v, t.o, t.s, t._row_id]
         Stream key: [t._row_id]
          Upstream
           Output: [k, v, o, s, _row_id]
           Stream key: [_row_id]
          BatchPlanNode
           Output: [t.v, t.o, t.s, t._row_id]
           Stream key: [t._row_id]
           AppendOnly

    Table 0
      columns: [count:bigint]
      primary key: []
      values indices: [0]

    Table 1
      columns: [count(t.v):bigint]
      primary key: []
      values indices: [0]

    Table 2
      columns: [t.o:integer, t._row_id:bigint, t.s:varchar, ',':Varchar:varchar]
      primary key: [$0 ASC, $1 ASC]
      values indices: [0, 1, 2, 3]

    Table 4294967294
      columns: [a1:bigint, a2:varchar]
      primary key: []
      values indices: [0, 1]

- id: count_string_agg_on_AO
  before:
  - create_tables
  sql: |
    select count(v) as a1, string_agg(s, ',' order by o) as a2 from AO;
  stream_plan: |
    StreamMaterialize { columns: [a1, a2], pk_columns: [] }
      StreamProject { exprs: [count(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST))] }
        StreamAppendOnlyGlobalSimpleAgg { aggs: [count, count(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST))] }
          StreamExchange { dist: Single }
            StreamProject { exprs: [ao.v, ao.s, ',':Varchar, ao.o, ao._row_id] }
              StreamTableScan { table: ao, columns: [ao.v, ao.o, ao.s, ao._row_id], pk: [ao._row_id], distribution: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |+
    Fragment 0
      StreamMaterialize { columns: [a1, a2], pk_columns: [] }
       materialized table: 4294967294
       Output: [count(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST))]
       Stream key: []
        StreamProject { exprs: [count(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST))] }
         Output: [count(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST))]
         Stream key: []
          StreamAppendOnlyGlobalSimpleAgg { aggs: [count, count(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST))] }
           state tables: [0, 1, 2]
           Output: [count, count(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST))]
           Stream key: []
            StreamExchange Single from 1
             Output: [ao.v, ao.s, ',':Varchar, ao.o, ao._row_id]
             Stream key: [ao._row_id]
             AppendOnly

    Fragment 1
      StreamProject { exprs: [ao.v, ao.s, ',':Varchar, ao.o, ao._row_id] }
       Output: [ao.v, ao.s, ',':Varchar, ao.o, ao._row_id]
       Stream key: [ao._row_id]
       AppendOnly
        Chain { table: ao, columns: [ao.v, ao.o, ao.s, ao._row_id], pk: [ao._row_id], distribution: UpstreamHashShard(ao._row_id) }
         Output: [ao.v, ao.o, ao.s, ao._row_id]
         Stream key: [ao._row_id]
         AppendOnly
          Upstream
           Output: [k, v, o, s, _row_id]
           Stream key: [_row_id]
          BatchPlanNode
           Output: [ao.v, ao.o, ao.s, ao._row_id]
           Stream key: [ao._row_id]
           AppendOnly

    Table 0
      columns: [count:bigint]
      primary key: []
      values indices: [0]

    Table 1
      columns: [count(ao.v):bigint]
      primary key: []
      values indices: [0]

    Table 2
      columns: [string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST)):varchar]
      primary key: []
      values indices: [0]

    Table 4294967294
      columns: [a1:bigint, a2:varchar]
      primary key: []
      values indices: [0, 1]

- id: extreme_string_agg_on_T
  before:
  - create_tables
  sql: |
    select max(v) as a1, string_agg(s, ',' order by o) as a2 from T;
  batch_plan: |
    BatchSimpleAgg { aggs: [max(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))] }
      BatchExchange { order: [], dist: Single }
        BatchProject { exprs: [t.v, t.s, ',':Varchar, t.o] }
          BatchScan { table: t, columns: [t.v, t.o, t.s], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1, a2], pk_columns: [] }
      StreamProject { exprs: [max(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))] }
        StreamGlobalSimpleAgg { aggs: [count, max(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))] }
          StreamExchange { dist: Single }
            StreamProject { exprs: [t.v, t.s, ',':Varchar, t.o, t._row_id] }
              StreamTableScan { table: t, columns: [t.v, t.o, t.s, t._row_id], pk: [t._row_id], distribution: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |+
    Fragment 0
      StreamMaterialize { columns: [a1, a2], pk_columns: [] }
       materialized table: 4294967294
       Output: [max(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))]
       Stream key: []
        StreamProject { exprs: [max(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))] }
         Output: [max(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))]
         Stream key: []
          StreamGlobalSimpleAgg { aggs: [count, max(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))] }
           state tables: [0, 1, 2]
           Output: [count, max(t.v), string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))]
           Stream key: []
            StreamExchange Single from 1
             Output: [t.v, t.s, ',':Varchar, t.o, t._row_id]
             Stream key: [t._row_id]

    Fragment 1
      StreamProject { exprs: [t.v, t.s, ',':Varchar, t.o, t._row_id] }
       Output: [t.v, t.s, ',':Varchar, t.o, t._row_id]
       Stream key: [t._row_id]
        Chain { table: t, columns: [t.v, t.o, t.s, t._row_id], pk: [t._row_id], distribution: UpstreamHashShard(t._row_id) }
         Output: [t.v, t.o, t.s, t._row_id]
         Stream key: [t._row_id]
          Upstream
           Output: [k, v, o, s, _row_id]
           Stream key: [_row_id]
          BatchPlanNode
           Output: [t.v, t.o, t.s, t._row_id]
           Stream key: [t._row_id]
           AppendOnly

    Table 0
      columns: [count:bigint]
      primary key: []
      values indices: [0]

    Table 1
      columns: [t.v:integer, t._row_id:bigint]
      primary key: [$0 DESC, $1 ASC]
      values indices: [0, 1]

    Table 2
      columns: [t.o:integer, t._row_id:bigint, t.s:varchar, ',':Varchar:varchar]
      primary key: [$0 ASC, $1 ASC]
      values indices: [0, 1, 2, 3]

    Table 4294967294
      columns: [a1:integer, a2:varchar]
      primary key: []
      values indices: [0, 1]

- id: extreme_string_agg_on_AO
  before:
  - create_tables
  sql: |
    select max(v) as a1, string_agg(s, ',' order by o) as a2 from AO;
  stream_plan: |
    StreamMaterialize { columns: [a1, a2], pk_columns: [] }
      StreamProject { exprs: [max(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST))] }
        StreamAppendOnlyGlobalSimpleAgg { aggs: [count, max(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST))] }
          StreamExchange { dist: Single }
            StreamProject { exprs: [ao.v, ao.s, ',':Varchar, ao.o, ao._row_id] }
              StreamTableScan { table: ao, columns: [ao.v, ao.o, ao.s, ao._row_id], pk: [ao._row_id], distribution: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |+
    Fragment 0
      StreamMaterialize { columns: [a1, a2], pk_columns: [] }
       materialized table: 4294967294
       Output: [max(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST))]
       Stream key: []
        StreamProject { exprs: [max(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST))] }
         Output: [max(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST))]
         Stream key: []
          StreamAppendOnlyGlobalSimpleAgg { aggs: [count, max(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST))] }
           state tables: [0, 1, 2]
           Output: [count, max(ao.v), string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST))]
           Stream key: []
            StreamExchange Single from 1
             Output: [ao.v, ao.s, ',':Varchar, ao.o, ao._row_id]
             Stream key: [ao._row_id]
             AppendOnly

    Fragment 1
      StreamProject { exprs: [ao.v, ao.s, ',':Varchar, ao.o, ao._row_id] }
       Output: [ao.v, ao.s, ',':Varchar, ao.o, ao._row_id]
       Stream key: [ao._row_id]
       AppendOnly
        Chain { table: ao, columns: [ao.v, ao.o, ao.s, ao._row_id], pk: [ao._row_id], distribution: UpstreamHashShard(ao._row_id) }
         Output: [ao.v, ao.o, ao.s, ao._row_id]
         Stream key: [ao._row_id]
         AppendOnly
          Upstream
           Output: [k, v, o, s, _row_id]
           Stream key: [_row_id]
          BatchPlanNode
           Output: [ao.v, ao.o, ao.s, ao._row_id]
           Stream key: [ao._row_id]
           AppendOnly

    Table 0
      columns: [count:bigint]
      primary key: []
      values indices: [0]

    Table 1
      columns: [max(ao.v):integer]
      primary key: []
      values indices: [0]

    Table 2
      columns: [string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST)):varchar]
      primary key: []
      values indices: [0]

    Table 4294967294
      columns: [a1:integer, a2:varchar]
      primary key: []
      values indices: [0, 1]

- id: extreme_on_T_by_k
  before:
  - create_tables
  sql: |
    select max(v) as a1 from T group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [max(t.v)] }
        BatchHashAgg { group_key: [t.k], aggs: [max(t.v)] }
          BatchExchange { order: [], dist: HashShard(t.k) }
            BatchScan { table: t, columns: [t.k, t.v], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1, t.k(hidden)], pk_columns: [t.k] }
      StreamProject { exprs: [max(t.v), t.k] }
        StreamHashAgg { group_key: [t.k], aggs: [count, max(t.v)] }
          StreamExchange { dist: HashShard(t.k) }
            StreamTableScan { table: t, columns: [t.k, t.v, t._row_id], pk: [t._row_id], distribution: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |+
    Fragment 0
      StreamMaterialize { columns: [a1, t.k(hidden)], pk_columns: [t.k] }
       materialized table: 4294967294
       Output: [max(t.v), t.k]
       Stream key: [t.k]
        StreamProject { exprs: [max(t.v), t.k] }
         Output: [max(t.v), t.k]
         Stream key: [t.k]
          StreamHashAgg { group_key: [t.k], aggs: [count, max(t.v)] }
           state tables: [0, 1]
           Output: [t.k, count, max(t.v)]
           Stream key: [t.k]
            StreamExchange Hash([0]) from 1
             Output: [t.k, t.v, t._row_id]
             Stream key: [t._row_id]

    Fragment 1
      Chain { table: t, columns: [t.k, t.v, t._row_id], pk: [t._row_id], distribution: UpstreamHashShard(t._row_id) }
       Output: [t.k, t.v, t._row_id]
       Stream key: [t._row_id]
        Upstream
         Output: [k, v, o, s, _row_id]
         Stream key: [_row_id]
        BatchPlanNode
         Output: [t.k, t.v, t._row_id]
         Stream key: [t._row_id]
         AppendOnly

    Table 0
      columns: [t.k:integer, count:bigint]
      primary key: [$0 ASC]
      values indices: [0, 1]

    Table 1
      columns: [t.k:integer, t.v:integer, t._row_id:bigint]
      primary key: [$0 ASC, $1 DESC, $2 ASC]
      values indices: [0, 1, 2]

    Table 4294967294
      columns: [a1:integer, t.k:integer]
      primary key: [$1 ASC]
      values indices: [0, 1]

- id: extreme_on_Tk_by_k
  before:
  - create_tables
  sql: |
    select max(v) as a1 from Tk group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [max(tk.v)] }
        BatchSortAgg { group_key: [tk.k], aggs: [max(tk.v)] }
          BatchScan { table: tk, columns: [tk.k, tk.v], distribution: UpstreamHashShard(tk.k) }
  stream_plan: |
    StreamMaterialize { columns: [a1, tk.k(hidden)], pk_columns: [tk.k] }
      StreamProject { exprs: [max(tk.v), tk.k] }
        StreamHashAgg { group_key: [tk.k], aggs: [count, max(tk.v)] }
          StreamTableScan { table: tk, columns: [tk.k, tk.v, tk.t._row_id], pk: [tk.t._row_id], distribution: UpstreamHashShard(tk.k) }
  stream_dist_plan: |+
    Fragment 0
      StreamMaterialize { columns: [a1, tk.k(hidden)], pk_columns: [tk.k] }
       materialized table: 4294967294
       Output: [max(tk.v), tk.k]
       Stream key: [tk.k]
        StreamProject { exprs: [max(tk.v), tk.k] }
         Output: [max(tk.v), tk.k]
         Stream key: [tk.k]
          StreamHashAgg { group_key: [tk.k], aggs: [count, max(tk.v)] }
           state tables: [0, 1]
           Output: [tk.k, count, max(tk.v)]
           Stream key: [tk.k]
            Chain { table: tk, columns: [tk.k, tk.v, tk.t._row_id], pk: [tk.t._row_id], distribution: UpstreamHashShard(tk.k) }
             Output: [tk.k, tk.v, tk.t._row_id]
             Stream key: [tk.t._row_id]
              Upstream
               Output: [k, v, o, s, t._row_id]
               Stream key: [t._row_id]
              BatchPlanNode
               Output: [tk.k, tk.v, tk.t._row_id]
               Stream key: [tk.t._row_id]
               AppendOnly

    Table 0
      columns: [tk.k:integer, count:bigint]
      primary key: [$0 ASC]
      values indices: [0, 1]

    Table 1
      columns: [tk.k:integer, tk.v:integer, tk.t._row_id:bigint]
      primary key: [$0 ASC, $1 DESC, $2 ASC]
      values indices: [0, 1, 2]

    Table 4294967294
      columns: [a1:integer, tk.k:integer]
      primary key: [$1 ASC]
      values indices: [0, 1]

- id: extreme_on_S_by_k
  before:
  - create_tables
  sql: |
    select max(v) as a1 from S group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [max(s.v)] }
        BatchHashAgg { group_key: [s.k], aggs: [max(s.v)] }
          BatchScan { table: s, columns: [s.k, s.v], distribution: UpstreamHashShard() }
  stream_plan: |
    StreamMaterialize { columns: [a1, s.k(hidden)], pk_columns: [s.k] }
      StreamProject { exprs: [max(s.v), s.k] }
        StreamHashAgg { group_key: [s.k], aggs: [count, max(s.v)] }
          StreamExchange { dist: HashShard(s.k) }
            StreamTableScan { table: s, columns: [s.k, s.v, s.o, s.t._row_id], pk: [s.t._row_id], distribution: Single }
  stream_dist_plan: |+
    Fragment 0
      StreamMaterialize { columns: [a1, s.k(hidden)], pk_columns: [s.k] }
       materialized table: 4294967294
       Output: [max(s.v), s.k]
       Stream key: [s.k]
        StreamProject { exprs: [max(s.v), s.k] }
         Output: [max(s.v), s.k]
         Stream key: [s.k]
          StreamHashAgg { group_key: [s.k], aggs: [count, max(s.v)] }
           state tables: [0, 1]
           Output: [s.k, count, max(s.v)]
           Stream key: [s.k]
            StreamExchange Hash([0]) from 1
             Output: [s.k, s.v, s.o, s.t._row_id]
             Stream key: [s.t._row_id]

    Fragment 1
      Chain { table: s, columns: [s.k, s.v, s.o, s.t._row_id], pk: [s.t._row_id], distribution: Single }
       Output: [s.k, s.v, s.o, s.t._row_id]
       Stream key: [s.t._row_id]
        Upstream
         Output: [k, v, o, s, t._row_id]
         Stream key: [t._row_id]
        BatchPlanNode
         Output: [s.k, s.v, s.o, s.t._row_id]
         Stream key: [s.t._row_id]
         AppendOnly

    Table 0
      columns: [s.k:integer, count:bigint]
      primary key: [$0 ASC]
      values indices: [0, 1]

    Table 1
      columns: [s.k:integer, s.v:integer, s.t._row_id:bigint]
      primary key: [$0 ASC, $1 DESC, $2 ASC]
      values indices: [0, 1, 2]

    Table 4294967294
      columns: [a1:integer, s.k:integer]
      primary key: [$1 ASC]
      values indices: [0, 1]

- id: extreme_on_AO_by_k
  before:
  - create_tables
  sql: |
    select max(v) as a1 from AO group by k;
  stream_plan: |
    StreamMaterialize { columns: [a1, ao.k(hidden)], pk_columns: [ao.k] }
      StreamProject { exprs: [max(ao.v), ao.k] }
        StreamAppendOnlyHashAgg { group_key: [ao.k], aggs: [count, max(ao.v)] }
          StreamExchange { dist: HashShard(ao.k) }
            StreamTableScan { table: ao, columns: [ao.k, ao.v, ao._row_id], pk: [ao._row_id], distribution: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |+
    Fragment 0
      StreamMaterialize { columns: [a1, ao.k(hidden)], pk_columns: [ao.k] }
       materialized table: 4294967294
       Output: [max(ao.v), ao.k]
       Stream key: [ao.k]
        StreamProject { exprs: [max(ao.v), ao.k] }
         Output: [max(ao.v), ao.k]
         Stream key: [ao.k]
          StreamAppendOnlyHashAgg { group_key: [ao.k], aggs: [count, max(ao.v)] }
           state tables: [0, 1]
           Output: [ao.k, count, max(ao.v)]
           Stream key: [ao.k]
            StreamExchange Hash([0]) from 1
             Output: [ao.k, ao.v, ao._row_id]
             Stream key: [ao._row_id]
             AppendOnly

    Fragment 1
      Chain { table: ao, columns: [ao.k, ao.v, ao._row_id], pk: [ao._row_id], distribution: UpstreamHashShard(ao._row_id) }
       Output: [ao.k, ao.v, ao._row_id]
       Stream key: [ao._row_id]
       AppendOnly
        Upstream
         Output: [k, v, o, s, _row_id]
         Stream key: [_row_id]
        BatchPlanNode
         Output: [ao.k, ao.v, ao._row_id]
         Stream key: [ao._row_id]
         AppendOnly

    Table 0
      columns: [ao.k:integer, count:bigint]
      primary key: [$0 ASC]
      values indices: [0, 1]

    Table 1
      columns: [ao.k:integer, max(ao.v):integer]
      primary key: [$0 ASC]
      values indices: [0, 1]

    Table 4294967294
      columns: [a1:integer, ao.k:integer]
      primary key: [$1 ASC]
      values indices: [0, 1]

- id: sum_on_T_by_k
  before:
  - create_tables
  sql: |
    select sum(v) as a1 from T group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [sum(t.v)] }
        BatchHashAgg { group_key: [t.k], aggs: [sum(t.v)] }
          BatchExchange { order: [], dist: HashShard(t.k) }
            BatchScan { table: t, columns: [t.k, t.v], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1, t.k(hidden)], pk_columns: [t.k] }
      StreamProject { exprs: [sum(t.v), t.k] }
        StreamHashAgg { group_key: [t.k], aggs: [count, sum(t.v)] }
          StreamExchange { dist: HashShard(t.k) }
            StreamTableScan { table: t, columns: [t.k, t.v, t._row_id], pk: [t._row_id], distribution: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |+
    Fragment 0
      StreamMaterialize { columns: [a1, t.k(hidden)], pk_columns: [t.k] }
       materialized table: 4294967294
       Output: [sum(t.v), t.k]
       Stream key: [t.k]
        StreamProject { exprs: [sum(t.v), t.k] }
         Output: [sum(t.v), t.k]
         Stream key: [t.k]
          StreamHashAgg { group_key: [t.k], aggs: [count, sum(t.v)] }
           state tables: [0, 1]
           Output: [t.k, count, sum(t.v)]
           Stream key: [t.k]
            StreamExchange Hash([0]) from 1
             Output: [t.k, t.v, t._row_id]
             Stream key: [t._row_id]

    Fragment 1
      Chain { table: t, columns: [t.k, t.v, t._row_id], pk: [t._row_id], distribution: UpstreamHashShard(t._row_id) }
       Output: [t.k, t.v, t._row_id]
       Stream key: [t._row_id]
        Upstream
         Output: [k, v, o, s, _row_id]
         Stream key: [_row_id]
        BatchPlanNode
         Output: [t.k, t.v, t._row_id]
         Stream key: [t._row_id]
         AppendOnly

    Table 0
      columns: [t.k:integer, count:bigint]
      primary key: [$0 ASC]
      values indices: [0, 1]

    Table 1
      columns: [t.k:integer, sum(t.v):bigint]
      primary key: [$0 ASC]
      values indices: [0, 1]

    Table 4294967294
      columns: [a1:bigint, t.k:integer]
      primary key: [$1 ASC]
      values indices: [0, 1]

- id: sum_on_Tk_by_k
  before:
  - create_tables
  sql: |
    select sum(v) as a1 from Tk group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [sum(tk.v)] }
        BatchSortAgg { group_key: [tk.k], aggs: [sum(tk.v)] }
          BatchScan { table: tk, columns: [tk.k, tk.v], distribution: UpstreamHashShard(tk.k) }
  stream_plan: |
    StreamMaterialize { columns: [a1, tk.k(hidden)], pk_columns: [tk.k] }
      StreamProject { exprs: [sum(tk.v), tk.k] }
        StreamHashAgg { group_key: [tk.k], aggs: [count, sum(tk.v)] }
          StreamTableScan { table: tk, columns: [tk.k, tk.v, tk.t._row_id], pk: [tk.t._row_id], distribution: UpstreamHashShard(tk.k) }
  stream_dist_plan: |+
    Fragment 0
      StreamMaterialize { columns: [a1, tk.k(hidden)], pk_columns: [tk.k] }
       materialized table: 4294967294
       Output: [sum(tk.v), tk.k]
       Stream key: [tk.k]
        StreamProject { exprs: [sum(tk.v), tk.k] }
         Output: [sum(tk.v), tk.k]
         Stream key: [tk.k]
          StreamHashAgg { group_key: [tk.k], aggs: [count, sum(tk.v)] }
           state tables: [0, 1]
           Output: [tk.k, count, sum(tk.v)]
           Stream key: [tk.k]
            Chain { table: tk, columns: [tk.k, tk.v, tk.t._row_id], pk: [tk.t._row_id], distribution: UpstreamHashShard(tk.k) }
             Output: [tk.k, tk.v, tk.t._row_id]
             Stream key: [tk.t._row_id]
              Upstream
               Output: [k, v, o, s, t._row_id]
               Stream key: [t._row_id]
              BatchPlanNode
               Output: [tk.k, tk.v, tk.t._row_id]
               Stream key: [tk.t._row_id]
               AppendOnly

    Table 0
      columns: [tk.k:integer, count:bigint]
      primary key: [$0 ASC]
      values indices: [0, 1]

    Table 1
      columns: [tk.k:integer, sum(tk.v):bigint]
      primary key: [$0 ASC]
      values indices: [0, 1]

    Table 4294967294
      columns: [a1:bigint, tk.k:integer]
      primary key: [$1 ASC]
      values indices: [0, 1]

- id: sum_on_S_by_k
  before:
  - create_tables
  sql: |
    select sum(v) as a1 from S group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [sum(s.v)] }
        BatchHashAgg { group_key: [s.k], aggs: [sum(s.v)] }
          BatchScan { table: s, columns: [s.k, s.v], distribution: UpstreamHashShard() }
  stream_plan: |
    StreamMaterialize { columns: [a1, s.k(hidden)], pk_columns: [s.k] }
      StreamProject { exprs: [sum(s.v), s.k] }
        StreamHashAgg { group_key: [s.k], aggs: [count, sum(s.v)] }
          StreamExchange { dist: HashShard(s.k) }
            StreamTableScan { table: s, columns: [s.k, s.v, s.o, s.t._row_id], pk: [s.t._row_id], distribution: Single }
  stream_dist_plan: |+
    Fragment 0
      StreamMaterialize { columns: [a1, s.k(hidden)], pk_columns: [s.k] }
       materialized table: 4294967294
       Output: [sum(s.v), s.k]
       Stream key: [s.k]
        StreamProject { exprs: [sum(s.v), s.k] }
         Output: [sum(s.v), s.k]
         Stream key: [s.k]
          StreamHashAgg { group_key: [s.k], aggs: [count, sum(s.v)] }
           state tables: [0, 1]
           Output: [s.k, count, sum(s.v)]
           Stream key: [s.k]
            StreamExchange Hash([0]) from 1
             Output: [s.k, s.v, s.o, s.t._row_id]
             Stream key: [s.t._row_id]

    Fragment 1
      Chain { table: s, columns: [s.k, s.v, s.o, s.t._row_id], pk: [s.t._row_id], distribution: Single }
       Output: [s.k, s.v, s.o, s.t._row_id]
       Stream key: [s.t._row_id]
        Upstream
         Output: [k, v, o, s, t._row_id]
         Stream key: [t._row_id]
        BatchPlanNode
         Output: [s.k, s.v, s.o, s.t._row_id]
         Stream key: [s.t._row_id]
         AppendOnly

    Table 0
      columns: [s.k:integer, count:bigint]
      primary key: [$0 ASC]
      values indices: [0, 1]

    Table 1
      columns: [s.k:integer, sum(s.v):bigint]
      primary key: [$0 ASC]
      values indices: [0, 1]

    Table 4294967294
      columns: [a1:bigint, s.k:integer]
      primary key: [$1 ASC]
      values indices: [0, 1]

- id: sum_on_AO_by_k
  before:
  - create_tables
  sql: |
    select sum(v) as a1 from AO group by k;
  stream_plan: |
    StreamMaterialize { columns: [a1, ao.k(hidden)], pk_columns: [ao.k] }
      StreamProject { exprs: [sum(ao.v), ao.k] }
        StreamAppendOnlyHashAgg { group_key: [ao.k], aggs: [count, sum(ao.v)] }
          StreamExchange { dist: HashShard(ao.k) }
            StreamTableScan { table: ao, columns: [ao.k, ao.v, ao._row_id], pk: [ao._row_id], distribution: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |+
    Fragment 0
      StreamMaterialize { columns: [a1, ao.k(hidden)], pk_columns: [ao.k] }
       materialized table: 4294967294
       Output: [sum(ao.v), ao.k]
       Stream key: [ao.k]
        StreamProject { exprs: [sum(ao.v), ao.k] }
         Output: [sum(ao.v), ao.k]
         Stream key: [ao.k]
          StreamAppendOnlyHashAgg { group_key: [ao.k], aggs: [count, sum(ao.v)] }
           state tables: [0, 1]
           Output: [ao.k, count, sum(ao.v)]
           Stream key: [ao.k]
            StreamExchange Hash([0]) from 1
             Output: [ao.k, ao.v, ao._row_id]
             Stream key: [ao._row_id]
             AppendOnly

    Fragment 1
      Chain { table: ao, columns: [ao.k, ao.v, ao._row_id], pk: [ao._row_id], distribution: UpstreamHashShard(ao._row_id) }
       Output: [ao.k, ao.v, ao._row_id]
       Stream key: [ao._row_id]
       AppendOnly
        Upstream
         Output: [k, v, o, s, _row_id]
         Stream key: [_row_id]
        BatchPlanNode
         Output: [ao.k, ao.v, ao._row_id]
         Stream key: [ao._row_id]
         AppendOnly

    Table 0
      columns: [ao.k:integer, count:bigint]
      primary key: [$0 ASC]
      values indices: [0, 1]

    Table 1
      columns: [ao.k:integer, sum(ao.v):bigint]
      primary key: [$0 ASC]
      values indices: [0, 1]

    Table 4294967294
      columns: [a1:bigint, ao.k:integer]
      primary key: [$1 ASC]
      values indices: [0, 1]

- id: cnt_on_T_by_k
  before:
  - create_tables
  sql: |
    select count(v) as a1 from T group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [count(t.v)] }
        BatchHashAgg { group_key: [t.k], aggs: [count(t.v)] }
          BatchExchange { order: [], dist: HashShard(t.k) }
            BatchScan { table: t, columns: [t.k, t.v], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1, t.k(hidden)], pk_columns: [t.k] }
      StreamProject { exprs: [count(t.v), t.k] }
        StreamHashAgg { group_key: [t.k], aggs: [count, count(t.v)] }
          StreamExchange { dist: HashShard(t.k) }
            StreamTableScan { table: t, columns: [t.k, t.v, t._row_id], pk: [t._row_id], distribution: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |+
    Fragment 0
      StreamMaterialize { columns: [a1, t.k(hidden)], pk_columns: [t.k] }
       materialized table: 4294967294
       Output: [count(t.v), t.k]
       Stream key: [t.k]
        StreamProject { exprs: [count(t.v), t.k] }
         Output: [count(t.v), t.k]
         Stream key: [t.k]
          StreamHashAgg { group_key: [t.k], aggs: [count, count(t.v)] }
           state tables: [0, 1]
           Output: [t.k, count, count(t.v)]
           Stream key: [t.k]
            StreamExchange Hash([0]) from 1
             Output: [t.k, t.v, t._row_id]
             Stream key: [t._row_id]

    Fragment 1
      Chain { table: t, columns: [t.k, t.v, t._row_id], pk: [t._row_id], distribution: UpstreamHashShard(t._row_id) }
       Output: [t.k, t.v, t._row_id]
       Stream key: [t._row_id]
        Upstream
         Output: [k, v, o, s, _row_id]
         Stream key: [_row_id]
        BatchPlanNode
         Output: [t.k, t.v, t._row_id]
         Stream key: [t._row_id]
         AppendOnly

    Table 0
      columns: [t.k:integer, count:bigint]
      primary key: [$0 ASC]
      values indices: [0, 1]

    Table 1
      columns: [t.k:integer, count(t.v):bigint]
      primary key: [$0 ASC]
      values indices: [0, 1]

    Table 4294967294
      columns: [a1:bigint, t.k:integer]
      primary key: [$1 ASC]
      values indices: [0, 1]

- id: cnt_on_Tk_by_k
  before:
  - create_tables
  sql: |
    select count(v) as a1 from Tk group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [count(tk.v)] }
        BatchSortAgg { group_key: [tk.k], aggs: [count(tk.v)] }
          BatchScan { table: tk, columns: [tk.k, tk.v], distribution: UpstreamHashShard(tk.k) }
  stream_plan: |
    StreamMaterialize { columns: [a1, tk.k(hidden)], pk_columns: [tk.k] }
      StreamProject { exprs: [count(tk.v), tk.k] }
        StreamHashAgg { group_key: [tk.k], aggs: [count, count(tk.v)] }
          StreamTableScan { table: tk, columns: [tk.k, tk.v, tk.t._row_id], pk: [tk.t._row_id], distribution: UpstreamHashShard(tk.k) }
  stream_dist_plan: |+
    Fragment 0
      StreamMaterialize { columns: [a1, tk.k(hidden)], pk_columns: [tk.k] }
       materialized table: 4294967294
       Output: [count(tk.v), tk.k]
       Stream key: [tk.k]
        StreamProject { exprs: [count(tk.v), tk.k] }
         Output: [count(tk.v), tk.k]
         Stream key: [tk.k]
          StreamHashAgg { group_key: [tk.k], aggs: [count, count(tk.v)] }
           state tables: [0, 1]
           Output: [tk.k, count, count(tk.v)]
           Stream key: [tk.k]
            Chain { table: tk, columns: [tk.k, tk.v, tk.t._row_id], pk: [tk.t._row_id], distribution: UpstreamHashShard(tk.k) }
             Output: [tk.k, tk.v, tk.t._row_id]
             Stream key: [tk.t._row_id]
              Upstream
               Output: [k, v, o, s, t._row_id]
               Stream key: [t._row_id]
              BatchPlanNode
               Output: [tk.k, tk.v, tk.t._row_id]
               Stream key: [tk.t._row_id]
               AppendOnly

    Table 0
      columns: [tk.k:integer, count:bigint]
      primary key: [$0 ASC]
      values indices: [0, 1]

    Table 1
      columns: [tk.k:integer, count(tk.v):bigint]
      primary key: [$0 ASC]
      values indices: [0, 1]

    Table 4294967294
      columns: [a1:bigint, tk.k:integer]
      primary key: [$1 ASC]
      values indices: [0, 1]

- id: cnt_on_S_by_k
  before:
  - create_tables
  sql: |
    select count(v) as a1 from S group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [count(s.v)] }
        BatchHashAgg { group_key: [s.k], aggs: [count(s.v)] }
          BatchScan { table: s, columns: [s.k, s.v], distribution: UpstreamHashShard() }
  stream_plan: |
    StreamMaterialize { columns: [a1, s.k(hidden)], pk_columns: [s.k] }
      StreamProject { exprs: [count(s.v), s.k] }
        StreamHashAgg { group_key: [s.k], aggs: [count, count(s.v)] }
          StreamExchange { dist: HashShard(s.k) }
            StreamTableScan { table: s, columns: [s.k, s.v, s.o, s.t._row_id], pk: [s.t._row_id], distribution: Single }
  stream_dist_plan: |+
    Fragment 0
      StreamMaterialize { columns: [a1, s.k(hidden)], pk_columns: [s.k] }
       materialized table: 4294967294
       Output: [count(s.v), s.k]
       Stream key: [s.k]
        StreamProject { exprs: [count(s.v), s.k] }
         Output: [count(s.v), s.k]
         Stream key: [s.k]
          StreamHashAgg { group_key: [s.k], aggs: [count, count(s.v)] }
           state tables: [0, 1]
           Output: [s.k, count, count(s.v)]
           Stream key: [s.k]
            StreamExchange Hash([0]) from 1
             Output: [s.k, s.v, s.o, s.t._row_id]
             Stream key: [s.t._row_id]

    Fragment 1
      Chain { table: s, columns: [s.k, s.v, s.o, s.t._row_id], pk: [s.t._row_id], distribution: Single }
       Output: [s.k, s.v, s.o, s.t._row_id]
       Stream key: [s.t._row_id]
        Upstream
         Output: [k, v, o, s, t._row_id]
         Stream key: [t._row_id]
        BatchPlanNode
         Output: [s.k, s.v, s.o, s.t._row_id]
         Stream key: [s.t._row_id]
         AppendOnly

    Table 0
      columns: [s.k:integer, count:bigint]
      primary key: [$0 ASC]
      values indices: [0, 1]

    Table 1
      columns: [s.k:integer, count(s.v):bigint]
      primary key: [$0 ASC]
      values indices: [0, 1]

    Table 4294967294
      columns: [a1:bigint, s.k:integer]
      primary key: [$1 ASC]
      values indices: [0, 1]

- id: cnt_on_AO_by_k
  before:
  - create_tables
  sql: |
    select count(v) as a1 from AO group by k;
  stream_plan: |
    StreamMaterialize { columns: [a1, ao.k(hidden)], pk_columns: [ao.k] }
      StreamProject { exprs: [count(ao.v), ao.k] }
        StreamAppendOnlyHashAgg { group_key: [ao.k], aggs: [count, count(ao.v)] }
          StreamExchange { dist: HashShard(ao.k) }
            StreamTableScan { table: ao, columns: [ao.k, ao.v, ao._row_id], pk: [ao._row_id], distribution: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |+
    Fragment 0
      StreamMaterialize { columns: [a1, ao.k(hidden)], pk_columns: [ao.k] }
       materialized table: 4294967294
       Output: [count(ao.v), ao.k]
       Stream key: [ao.k]
        StreamProject { exprs: [count(ao.v), ao.k] }
         Output: [count(ao.v), ao.k]
         Stream key: [ao.k]
          StreamAppendOnlyHashAgg { group_key: [ao.k], aggs: [count, count(ao.v)] }
           state tables: [0, 1]
           Output: [ao.k, count, count(ao.v)]
           Stream key: [ao.k]
            StreamExchange Hash([0]) from 1
             Output: [ao.k, ao.v, ao._row_id]
             Stream key: [ao._row_id]
             AppendOnly

    Fragment 1
      Chain { table: ao, columns: [ao.k, ao.v, ao._row_id], pk: [ao._row_id], distribution: UpstreamHashShard(ao._row_id) }
       Output: [ao.k, ao.v, ao._row_id]
       Stream key: [ao._row_id]
       AppendOnly
        Upstream
         Output: [k, v, o, s, _row_id]
         Stream key: [_row_id]
        BatchPlanNode
         Output: [ao.k, ao.v, ao._row_id]
         Stream key: [ao._row_id]
         AppendOnly

    Table 0
      columns: [ao.k:integer, count:bigint]
      primary key: [$0 ASC]
      values indices: [0, 1]

    Table 1
      columns: [ao.k:integer, count(ao.v):bigint]
      primary key: [$0 ASC]
      values indices: [0, 1]

    Table 4294967294
      columns: [a1:bigint, ao.k:integer]
      primary key: [$1 ASC]
      values indices: [0, 1]

- id: string_agg_on_T_by_k
  before:
  - create_tables
  sql: |
    select string_agg(s, ',' order by o) as a1 from T group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))] }
        BatchHashAgg { group_key: [t.k], aggs: [string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))] }
          BatchExchange { order: [], dist: HashShard(t.k) }
            BatchProject { exprs: [t.k, t.s, ',':Varchar, t.o] }
              BatchScan { table: t, columns: [t.k, t.o, t.s], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a1, t.k(hidden)], pk_columns: [t.k] }
      StreamProject { exprs: [string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST)), t.k] }
        StreamHashAgg { group_key: [t.k], aggs: [count, string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))] }
          StreamExchange { dist: HashShard(t.k) }
            StreamProject { exprs: [t.k, t.s, ',':Varchar, t.o, t._row_id] }
              StreamTableScan { table: t, columns: [t.k, t.o, t.s, t._row_id], pk: [t._row_id], distribution: UpstreamHashShard(t._row_id) }
  stream_dist_plan: |+
    Fragment 0
      StreamMaterialize { columns: [a1, t.k(hidden)], pk_columns: [t.k] }
       materialized table: 4294967294
       Output: [string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST)), t.k]
       Stream key: [t.k]
        StreamProject { exprs: [string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST)), t.k] }
         Output: [string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST)), t.k]
         Stream key: [t.k]
          StreamHashAgg { group_key: [t.k], aggs: [count, string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))] }
           state tables: [0, 1]
           Output: [t.k, count, string_agg(t.s, ',':Varchar order_by(t.o ASC NULLS LAST))]
           Stream key: [t.k]
            StreamExchange Hash([0]) from 1
             Output: [t.k, t.s, ',':Varchar, t.o, t._row_id]
             Stream key: [t._row_id]

    Fragment 1
      StreamProject { exprs: [t.k, t.s, ',':Varchar, t.o, t._row_id] }
       Output: [t.k, t.s, ',':Varchar, t.o, t._row_id]
       Stream key: [t._row_id]
        Chain { table: t, columns: [t.k, t.o, t.s, t._row_id], pk: [t._row_id], distribution: UpstreamHashShard(t._row_id) }
         Output: [t.k, t.o, t.s, t._row_id]
         Stream key: [t._row_id]
          Upstream
           Output: [k, v, o, s, _row_id]
           Stream key: [_row_id]
          BatchPlanNode
           Output: [t.k, t.o, t.s, t._row_id]
           Stream key: [t._row_id]
           AppendOnly

    Table 0
      columns: [t.k:integer, count:bigint]
      primary key: [$0 ASC]
      values indices: [0, 1]

    Table 1
      columns: [t.k:integer, t.o:integer, t._row_id:bigint, t.s:varchar, ',':Varchar:varchar]
      primary key: [$0 ASC, $1 ASC, $2 ASC]
      values indices: [0, 1, 2, 3, 4]

    Table 4294967294
      columns: [a1:varchar, t.k:integer]
      primary key: [$1 ASC]
      values indices: [0, 1]

- id: string_agg_on_Tk_by_k
  before:
  - create_tables
  sql: |
    select string_agg(s, ',' order by o) as a1 from Tk group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [string_agg(tk.s, ',':Varchar order_by(tk.o ASC NULLS LAST))] }
        BatchSortAgg { group_key: [tk.k], aggs: [string_agg(tk.s, ',':Varchar order_by(tk.o ASC NULLS LAST))] }
          BatchProject { exprs: [tk.k, tk.s, ',':Varchar, tk.o] }
            BatchScan { table: tk, columns: [tk.k, tk.o, tk.s], distribution: UpstreamHashShard(tk.k) }
  stream_plan: |
    StreamMaterialize { columns: [a1, tk.k(hidden)], pk_columns: [tk.k] }
      StreamProject { exprs: [string_agg(tk.s, ',':Varchar order_by(tk.o ASC NULLS LAST)), tk.k] }
        StreamHashAgg { group_key: [tk.k], aggs: [count, string_agg(tk.s, ',':Varchar order_by(tk.o ASC NULLS LAST))] }
          StreamProject { exprs: [tk.k, tk.s, ',':Varchar, tk.o, tk.t._row_id] }
            StreamTableScan { table: tk, columns: [tk.k, tk.o, tk.s, tk.t._row_id], pk: [tk.t._row_id], distribution: UpstreamHashShard(tk.k) }
  stream_dist_plan: |+
    Fragment 0
      StreamMaterialize { columns: [a1, tk.k(hidden)], pk_columns: [tk.k] }
       materialized table: 4294967294
       Output: [string_agg(tk.s, ',':Varchar order_by(tk.o ASC NULLS LAST)), tk.k]
       Stream key: [tk.k]
        StreamProject { exprs: [string_agg(tk.s, ',':Varchar order_by(tk.o ASC NULLS LAST)), tk.k] }
         Output: [string_agg(tk.s, ',':Varchar order_by(tk.o ASC NULLS LAST)), tk.k]
         Stream key: [tk.k]
          StreamHashAgg { group_key: [tk.k], aggs: [count, string_agg(tk.s, ',':Varchar order_by(tk.o ASC NULLS LAST))] }
           state tables: [0, 1]
           Output: [tk.k, count, string_agg(tk.s, ',':Varchar order_by(tk.o ASC NULLS LAST))]
           Stream key: [tk.k]
            StreamProject { exprs: [tk.k, tk.s, ',':Varchar, tk.o, tk.t._row_id] }
             Output: [tk.k, tk.s, ',':Varchar, tk.o, tk.t._row_id]
             Stream key: [tk.t._row_id]
              Chain { table: tk, columns: [tk.k, tk.o, tk.s, tk.t._row_id], pk: [tk.t._row_id], distribution: UpstreamHashShard(tk.k) }
               Output: [tk.k, tk.o, tk.s, tk.t._row_id]
               Stream key: [tk.t._row_id]
                Upstream
                 Output: [k, v, o, s, t._row_id]
                 Stream key: [t._row_id]
                BatchPlanNode
                 Output: [tk.k, tk.o, tk.s, tk.t._row_id]
                 Stream key: [tk.t._row_id]
                 AppendOnly

    Table 0
      columns: [tk.k:integer, count:bigint]
      primary key: [$0 ASC]
      values indices: [0, 1]

    Table 1
      columns: [tk.k:integer, tk.o:integer, tk.t._row_id:bigint, tk.s:varchar, ',':Varchar:varchar]
      primary key: [$0 ASC, $1 ASC, $2 ASC]
      values indices: [0, 1, 2, 3, 4]

    Table 4294967294
      columns: [a1:varchar, tk.k:integer]
      primary key: [$1 ASC]
      values indices: [0, 1]

- id: string_agg_on_S_by_k
  before:
  - create_tables
  sql: |
    select string_agg(s, ',' order by o) as a1 from S group by k;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [string_agg(s.s, ',':Varchar order_by(s.o ASC NULLS LAST))] }
        BatchHashAgg { group_key: [s.k], aggs: [string_agg(s.s, ',':Varchar order_by(s.o ASC NULLS LAST))] }
          BatchProject { exprs: [s.k, s.s, ',':Varchar, s.o] }
            BatchScan { table: s, columns: [s.k, s.o, s.s], distribution: UpstreamHashShard() }
  stream_plan: |
    StreamMaterialize { columns: [a1, s.k(hidden)], pk_columns: [s.k] }
      StreamProject { exprs: [string_agg(s.s, ',':Varchar order_by(s.o ASC NULLS LAST)), s.k] }
        StreamHashAgg { group_key: [s.k], aggs: [count, string_agg(s.s, ',':Varchar order_by(s.o ASC NULLS LAST))] }
          StreamExchange { dist: HashShard(s.k) }
            StreamProject { exprs: [s.k, s.s, ',':Varchar, s.o, s.t._row_id] }
              StreamTableScan { table: s, columns: [s.k, s.o, s.s, s.t._row_id], pk: [s.t._row_id], distribution: Single }
  stream_dist_plan: |+
    Fragment 0
      StreamMaterialize { columns: [a1, s.k(hidden)], pk_columns: [s.k] }
       materialized table: 4294967294
       Output: [string_agg(s.s, ',':Varchar order_by(s.o ASC NULLS LAST)), s.k]
       Stream key: [s.k]
        StreamProject { exprs: [string_agg(s.s, ',':Varchar order_by(s.o ASC NULLS LAST)), s.k] }
         Output: [string_agg(s.s, ',':Varchar order_by(s.o ASC NULLS LAST)), s.k]
         Stream key: [s.k]
          StreamHashAgg { group_key: [s.k], aggs: [count, string_agg(s.s, ',':Varchar order_by(s.o ASC NULLS LAST))] }
           state tables: [0, 1]
           Output: [s.k, count, string_agg(s.s, ',':Varchar order_by(s.o ASC NULLS LAST))]
           Stream key: [s.k]
            StreamExchange Hash([0]) from 1
             Output: [s.k, s.s, ',':Varchar, s.o, s.t._row_id]
             Stream key: [s.t._row_id]

    Fragment 1
      StreamProject { exprs: [s.k, s.s, ',':Varchar, s.o, s.t._row_id] }
       Output: [s.k, s.s, ',':Varchar, s.o, s.t._row_id]
       Stream key: [s.t._row_id]
        Chain { table: s, columns: [s.k, s.o, s.s, s.t._row_id], pk: [s.t._row_id], distribution: Single }
         Output: [s.k, s.o, s.s, s.t._row_id]
         Stream key: [s.t._row_id]
          Upstream
           Output: [k, v, o, s, t._row_id]
           Stream key: [t._row_id]
          BatchPlanNode
           Output: [s.k, s.o, s.s, s.t._row_id]
           Stream key: [s.t._row_id]
           AppendOnly

    Table 0
      columns: [s.k:integer, count:bigint]
      primary key: [$0 ASC]
      values indices: [0, 1]

    Table 1
      columns: [s.k:integer, s.o:integer, s.t._row_id:bigint, s.s:varchar, ',':Varchar:varchar]
      primary key: [$0 ASC, $1 ASC, $2 ASC]
      values indices: [0, 1, 2, 3, 4]

    Table 4294967294
      columns: [a1:varchar, s.k:integer]
      primary key: [$1 ASC]
      values indices: [0, 1]

- id: string_agg_on_AO_by_k
  before:
  - create_tables
  sql: |
    select string_agg(s, ',' order by o) as a1 from AO group by k;
  stream_plan: |
    StreamMaterialize { columns: [a1, ao.k(hidden)], pk_columns: [ao.k] }
      StreamProject { exprs: [string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST)), ao.k] }
        StreamAppendOnlyHashAgg { group_key: [ao.k], aggs: [count, string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST))] }
          StreamExchange { dist: HashShard(ao.k) }
            StreamProject { exprs: [ao.k, ao.s, ',':Varchar, ao.o, ao._row_id] }
              StreamTableScan { table: ao, columns: [ao.k, ao.o, ao.s, ao._row_id], pk: [ao._row_id], distribution: UpstreamHashShard(ao._row_id) }
  stream_dist_plan: |+
    Fragment 0
      StreamMaterialize { columns: [a1, ao.k(hidden)], pk_columns: [ao.k] }
       materialized table: 4294967294
       Output: [string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST)), ao.k]
       Stream key: [ao.k]
        StreamProject { exprs: [string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST)), ao.k] }
         Output: [string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST)), ao.k]
         Stream key: [ao.k]
          StreamAppendOnlyHashAgg { group_key: [ao.k], aggs: [count, string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST))] }
           state tables: [0, 1]
           Output: [ao.k, count, string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST))]
           Stream key: [ao.k]
            StreamExchange Hash([0]) from 1
             Output: [ao.k, ao.s, ',':Varchar, ao.o, ao._row_id]
             Stream key: [ao._row_id]
             AppendOnly

    Fragment 1
      StreamProject { exprs: [ao.k, ao.s, ',':Varchar, ao.o, ao._row_id] }
       Output: [ao.k, ao.s, ',':Varchar, ao.o, ao._row_id]
       Stream key: [ao._row_id]
       AppendOnly
        Chain { table: ao, columns: [ao.k, ao.o, ao.s, ao._row_id], pk: [ao._row_id], distribution: UpstreamHashShard(ao._row_id) }
         Output: [ao.k, ao.o, ao.s, ao._row_id]
         Stream key: [ao._row_id]
         AppendOnly
          Upstream
           Output: [k, v, o, s, _row_id]
           Stream key: [_row_id]
          BatchPlanNode
           Output: [ao.k, ao.o, ao.s, ao._row_id]
           Stream key: [ao._row_id]
           AppendOnly

    Table 0
      columns: [ao.k:integer, count:bigint]
      primary key: [$0 ASC]
      values indices: [0, 1]

    Table 1
      columns: [ao.k:integer, string_agg(ao.s, ',':Varchar order_by(ao.o ASC NULLS LAST)):varchar]
      primary key: [$0 ASC]
      values indices: [0, 1]

    Table 4294967294
      columns: [a1:varchar, ao.k:integer]
      primary key: [$1 ASC]
      values indices: [0, 1]

