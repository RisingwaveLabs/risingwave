# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- sql: |
    create table stream(id int, a int, b int) APPEND ONLY;
    create table version(id int, a int, b int, primary key (id));
    select stream.id as id1, stream.a as a1, version.id as id2, version.a as a2 from stream left join version FOR SYSTEM_TIME AS OF NOW() on stream.id = version.id
  stream_plan: |
    StreamMaterialize { columns: [id1, a1, id2, a2, stream._row_id(hidden)], pk_columns: [stream._row_id, id2, id1], pk_conflict: "no check" }
    └─StreamTemporalJoin { type: LeftOuter, predicate: stream.id = version.id, output: [stream.id, stream.a, version.id, version.a, stream._row_id] }
      ├─StreamExchange { dist: HashShard(stream.id) }
      | └─StreamTableScan { table: stream, columns: [stream.id, stream.a, stream._row_id], pk: [stream._row_id], dist: UpstreamHashShard(stream._row_id) }
      └─StreamNoShuffleExchange { dist: UpstreamHashShard(version.id) }
        └─StreamTableScan { table: version, columns: [version.id, version.a], pk: [version.id], dist: UpstreamHashShard(version.id) }
  batch_error: |-
    Not supported: do not support temporal join for batch queries
    HINT: please use temporal join in streaming queries
- sql: |
    create table stream(id int, a int, b int) APPEND ONLY;
    create table version(id int, a int, b int, primary key (id));
    select stream.id as id1, stream.a as a1, version.id as id2, version.a as a2 from stream join version FOR SYSTEM_TIME AS OF NOW() on stream.id = version.id where version.a < 10;
  stream_plan: |
    StreamMaterialize { columns: [id1, a1, id2, a2, stream._row_id(hidden)], pk_columns: [stream._row_id, id2, id1], pk_conflict: "no check" }
    └─StreamTemporalJoin { type: Inner, predicate: stream.id = version.id AND (version.a < 10:Int32), output: [stream.id, stream.a, version.id, version.a, stream._row_id] }
      ├─StreamExchange { dist: HashShard(stream.id) }
      | └─StreamTableScan { table: stream, columns: [stream.id, stream.a, stream._row_id], pk: [stream._row_id], dist: UpstreamHashShard(stream._row_id) }
      └─StreamNoShuffleExchange { dist: UpstreamHashShard(version.id) }
        └─StreamTableScan { table: version, columns: [version.id, version.a], pk: [version.id], dist: UpstreamHashShard(version.id) }
- sql: |
    create table stream(id int, a int, b int) APPEND ONLY;
    create table version(id int, a int, b int, primary key (id, a));
    select stream.id as id1, stream.a as a1, version.id as id2, version.a as a2 from stream left join version FOR SYSTEM_TIME AS OF NOW() on stream.a = version.a and stream.id = version.id where version.b != version.a;
  stream_plan: |
    StreamMaterialize { columns: [id1, a1, id2, a2, stream._row_id(hidden)], pk_columns: [stream._row_id, id2, a2, id1, a1], pk_conflict: "no check" }
    └─StreamTemporalJoin { type: Inner, predicate: stream.id = version.id AND stream.a = version.a AND (version.b <> version.a), output: [stream.id, stream.a, version.id, version.a, stream._row_id] }
      ├─StreamExchange { dist: HashShard(stream.id, stream.a) }
      | └─StreamTableScan { table: stream, columns: [stream.id, stream.a, stream._row_id], pk: [stream._row_id], dist: UpstreamHashShard(stream._row_id) }
      └─StreamNoShuffleExchange { dist: UpstreamHashShard(version.id, version.a) }
        └─StreamTableScan { table: version, columns: [version.id, version.a, version.b], pk: [version.id, version.a], dist: UpstreamHashShard(version.id, version.a) }
- sql: |
    create table stream(id int, a int, b int) APPEND ONLY;
    create table version(id int, a int, b int, primary key (id));
    select count(*) from stream left join version FOR SYSTEM_TIME AS OF NOW() on stream.id = version.id where version.a < 10;
  stream_plan: |
    StreamMaterialize { columns: [count], pk_columns: [], pk_conflict: "no check" }
    └─StreamProject { exprs: [sum0(count)] }
      └─StreamAppendOnlyGlobalSimpleAgg { aggs: [sum0(count), count] }
        └─StreamExchange { dist: Single }
          └─StreamStatelessLocalSimpleAgg { aggs: [count] }
            └─StreamTemporalJoin { type: Inner, predicate: stream.id = version.id AND (version.a < 10:Int32), output: [stream._row_id, stream.id, version.id] }
              ├─StreamExchange { dist: HashShard(stream.id) }
              | └─StreamTableScan { table: stream, columns: [stream.id, stream._row_id], pk: [stream._row_id], dist: UpstreamHashShard(stream._row_id) }
              └─StreamNoShuffleExchange { dist: UpstreamHashShard(version.id) }
                └─StreamTableScan { table: version, columns: [version.id, version.a], pk: [version.id], dist: UpstreamHashShard(version.id) }
- sql: |
    create table stream(id int, a int, b int) APPEND ONLY;
    create table version(id int, a int, b int, primary key (id, a));
    select stream.id as id1, stream.a as a1, version.id as id2, version.a as a2 from stream left join version FOR SYSTEM_TIME AS OF NOW() on stream.id = version.id where version.a < 10;
  stream_error: |-
    Not supported: Temporal join requires the lookup table's primary key contained exactly in the equivalence condition
    HINT: Please add the primary key of the lookup table to the join condition and remove any other conditions
- sql: |
    create table stream(id int, a int, b int);
    create table version(id int, a int, b int, primary key (id));
    select stream.id as id1, stream.a as a1, version.id as id2, version.a as a2 from stream left join version FOR SYSTEM_TIME AS OF NOW() on stream.id = version.id where version.a < 10;
  stream_error: |-
    Not supported: Temporal join requires a append-only left input
    HINT: Please ensure your left input is append-only
- sql: |
    create table stream(id int, a int, b int);
    create table version(id int, a int, b int, primary key (id));
    select stream.id as id1, stream.a as a1, version.id as id2, version.a as a2 from stream right join version FOR SYSTEM_TIME AS OF NOW() on stream.id = version.id where version.a < 10;
  stream_error: |-
    Not supported: exist dangling temporal scan
    HINT: please check your temporal join syntax e.g. consider removing the right outer join if it is being used.
