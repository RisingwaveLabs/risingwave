# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- name: test functional dependency for order key pruning (order by)
  sql: |
    create table t1 (id int primary key, i int);
    select id, i from t1 order by id, i limit 2;
  logical_plan: |-
    LogicalTopN { order: [t1.id ASC], limit: 2, offset: 0 }
    └─LogicalProject { exprs: [t1.id, t1.i] }
      └─LogicalScan { table: t1, columns: [t1.id, t1.i] }
  batch_plan: |-
    BatchSort { order: [t1.id ASC, t1.i ASC] }
    └─BatchTopN { order: [t1.id ASC], limit: 2, offset: 0 }
      └─BatchExchange { order: [], dist: Single }
        └─BatchLimit { limit: 2, offset: 0 }
          └─BatchScan { table: t1, columns: [t1.id, t1.i], limit: 2, distribution: UpstreamHashShard(t1.id) }
  stream_plan: |-
    StreamMaterialize { columns: [id, i], stream_key: [id], pk_columns: [id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [t1.id, t1.i] }
      └─StreamTopN { order: [t1.id ASC], limit: 2, offset: 0 }
        └─StreamExchange { dist: Single }
          └─StreamGroupTopN { order: [t1.id ASC], limit: 2, offset: 0, group_key: [_vnode] }
            └─StreamProject { exprs: [t1.id, t1.i, Vnode(t1.id) as _vnode] }
              └─StreamTableScan { table: t1, columns: [t1.id, t1.i], stream_scan_type: ArrangementBackfill, stream_key: [t1.id], pk: [id], dist: UpstreamHashShard(t1.id) }
- name: test functional dependency for order key pruning (index)
  sql: |
    create table t1 (v1 int, v2 int);
    create materialized view v as select count(*) cnt from t1;
    explain (verbose) create index mv_idx on v(cnt);
  explain_output: |
    StreamMaterialize { columns: [cnt], stream_key: [], pk_columns: [cnt], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(v.cnt) }
      └─StreamTableScan { table: v, columns: [v.cnt], stream_scan_type: ArrangementBackfill, stream_key: [], pk: [], dist: Single }
