# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- sql: |
    create table t1 (k int, v int) append only;
    select distinct on (k) k + v as sum from t1;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [$expr1] }
      └─BatchGroupTopN { order: [], limit: 1, offset: 0, group_key: [t1.k] }
        └─BatchExchange { order: [], dist: HashShard(t1.k) }
          └─BatchProject { exprs: [(t1.k + t1.v) as $expr1, t1.k] }
            └─BatchScan { table: t1, columns: [t1.k, t1.v], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [sum, t1.k(hidden)], stream_key: [t1.k], pk_columns: [t1.k], pk_conflict: NoCheck }
    └─StreamProject { exprs: [$expr1, t1.k] }
      └─StreamAppendOnlyDedup { dedup_cols: [t1.k] }
        └─StreamExchange { dist: HashShard(t1.k) }
          └─StreamProject { exprs: [(t1.k + t1.v) as $expr1, t1.k, t1._row_id] }
            └─StreamTableScan { table: t1, columns: [t1.k, t1.v, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
- sql: |
    create table t2 (k int, v int);
    select distinct on (k) k + v as sum from t2;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [$expr1] }
      └─BatchGroupTopN { order: [], limit: 1, offset: 0, group_key: [t2.k] }
        └─BatchExchange { order: [], dist: HashShard(t2.k) }
          └─BatchProject { exprs: [(t2.k + t2.v) as $expr1, t2.k] }
            └─BatchScan { table: t2, columns: [t2.k, t2.v], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [sum, t2.k(hidden)], stream_key: [t2.k], pk_columns: [t2.k], pk_conflict: NoCheck }
    └─StreamProject { exprs: [$expr1, t2.k] }
      └─StreamGroupTopN { order: [], limit: 1, offset: 0, group_key: [t2.k] }
        └─StreamExchange { dist: HashShard(t2.k) }
          └─StreamProject { exprs: [(t2.k + t2.v) as $expr1, t2.k, t2._row_id] }
            └─StreamTableScan { table: t2, columns: [t2.k, t2.v, t2._row_id], pk: [t2._row_id], dist: UpstreamHashShard(t2._row_id) }
- sql: |
    create table t (a int, b int, c int);
    select distinct on (foo, b) a as foo, b from t;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchGroupTopN { order: [], limit: 1, offset: 0, group_key: [t.a, t.b] }
      └─BatchExchange { order: [], dist: HashShard(t.a, t.b) }
        └─BatchScan { table: t, columns: [t.a, t.b], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [foo, b, t._row_id(hidden)], stream_key: [foo, b], pk_columns: [foo, b], pk_conflict: NoCheck }
    └─StreamGroupTopN { order: [], limit: 1, offset: 0, group_key: [t.a, t.b] }
      └─StreamExchange { dist: HashShard(t.a, t.b) }
        └─StreamTableScan { table: t, columns: [t.a, t.b, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
- sql: |
    create table t (a int, b int, c int);
    select distinct on (2) a as foo, b from t;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchGroupTopN { order: [], limit: 1, offset: 0, group_key: [t.b] }
      └─BatchExchange { order: [], dist: HashShard(t.b) }
        └─BatchScan { table: t, columns: [t.a, t.b], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [foo, b, t._row_id(hidden)], stream_key: [b], pk_columns: [b], pk_conflict: NoCheck }
    └─StreamGroupTopN { order: [], limit: 1, offset: 0, group_key: [t.b] }
      └─StreamExchange { dist: HashShard(t.b) }
        └─StreamTableScan { table: t, columns: [t.a, t.b, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
- sql: |
    create table t (a int, b int, c int);
    select distinct on (4) * from t;
  binder_error: 'Invalid input syntax: Invalid ordinal number in DISTINCT ON: 4'
