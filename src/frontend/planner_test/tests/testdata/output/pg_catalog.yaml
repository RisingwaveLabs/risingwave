# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- sql: |
    select * from pg_catalog.pg_type
  logical_plan: |-
    LogicalProject { exprs: [pg_type.oid, pg_type.typname, pg_type.typelem, pg_type.typnotnull, pg_type.typbasetype, pg_type.typtypmod, pg_type.typcollation, pg_type.typlen, pg_type.typnamespace, pg_type.typtype, pg_type.typrelid, pg_type.typdefault, pg_type.typcategory, pg_type.typreceive] }
    └─LogicalScan { table: pg_type, columns: [pg_type.oid, pg_type.typname, pg_type.typelem, pg_type.typnotnull, pg_type.typbasetype, pg_type.typtypmod, pg_type.typcollation, pg_type.typlen, pg_type.typnamespace, pg_type.typtype, pg_type.typrelid, pg_type.typdefault, pg_type.typcategory, pg_type.typreceive] }
  batch_plan: 'BatchScan { table: pg_type, columns: [pg_type.oid, pg_type.typname, pg_type.typelem, pg_type.typnotnull, pg_type.typbasetype, pg_type.typtypmod, pg_type.typcollation, pg_type.typlen, pg_type.typnamespace, pg_type.typtype, pg_type.typrelid, pg_type.typdefault, pg_type.typcategory, pg_type.typreceive], distribution: Single }'
- sql: |
    select * from pg_catalog.pg_namespace
  logical_plan: |-
    LogicalProject { exprs: [rw_schemas.id, rw_schemas.name, rw_schemas.owner, rw_schemas.acl] }
    └─LogicalShare { id: 2 }
      └─LogicalProject { exprs: [rw_schemas.id, rw_schemas.name, rw_schemas.owner, rw_schemas.acl] }
        └─LogicalScan { table: rw_schemas, columns: [rw_schemas.id, rw_schemas.name, rw_schemas.owner, rw_schemas.acl] }
  batch_plan: 'BatchScan { table: rw_schemas, columns: [rw_schemas.id, rw_schemas.name, rw_schemas.owner, rw_schemas.acl], distribution: Single }'
- sql: |
    select * from pg_catalog.pg_cast
  logical_plan: |-
    LogicalProject { exprs: [pg_cast.oid, pg_cast.castsource, pg_cast.casttarget, pg_cast.castcontext] }
    └─LogicalScan { table: pg_cast, columns: [pg_cast.oid, pg_cast.castsource, pg_cast.casttarget, pg_cast.castcontext] }
  batch_plan: 'BatchScan { table: pg_cast, columns: [pg_cast.oid, pg_cast.castsource, pg_cast.casttarget, pg_cast.castcontext], distribution: Single }'
- sql: |
    select pg_catalog.pg_get_userbyid(1)
  logical_plan: |-
    LogicalProject { exprs: [rw_users.name] }
    └─LogicalApply { type: LeftOuter, on: true, correlated_id: 1, max_one_row: true }
      ├─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
      └─LogicalProject { exprs: [rw_users.name] }
        └─LogicalFilter { predicate: (1:Int32 = rw_users.id) }
          └─LogicalShare { id: 2 }
            └─LogicalProject { exprs: [rw_users.id, rw_users.name, rw_users.create_db, rw_users.is_super, '********':Varchar] }
              └─LogicalScan { table: rw_users, columns: [rw_users.id, rw_users.name, rw_users.is_super, rw_users.create_db, rw_users.create_user, rw_users.can_login] }
  batch_plan: |-
    BatchNestedLoopJoin { type: LeftOuter, predicate: true, output: all }
    ├─BatchValues { rows: [[]] }
    └─BatchProject { exprs: [rw_users.name] }
      └─BatchFilter { predicate: (1:Int32 = rw_users.id) }
        └─BatchScan { table: rw_users, columns: [rw_users.name, rw_users.id], distribution: Single }
- sql: |
    select 'pg_namespace'::regclass
  logical_plan: |-
    LogicalProject { exprs: [2:Int32] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
  batch_plan: 'BatchValues { rows: [[2:Int32]] }'
