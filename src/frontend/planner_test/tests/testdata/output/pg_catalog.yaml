# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- sql: |
    select * from pg_catalog.pg_type
  logical_plan: |-
    LogicalProject { exprs: [rw_types.id, rw_types.name, rw_types.typelem, rw_types.typarray, rw_types.input_oid, false:Boolean, 0:Int32, -1:Int32, 0:Int32, 0:Int32, rw_schemas.id, 'b':Varchar, 0:Int32, null:Varchar, null:Varchar, null:Int32] }
    └─LogicalShare { id: 3 }
      └─LogicalProject { exprs: [rw_types.id, rw_types.name, rw_types.typelem, rw_types.typarray, rw_types.input_oid, false:Boolean, 0:Int32, -1:Int32, 0:Int32, 0:Int32, rw_schemas.id, 'b':Varchar, 0:Int32, null:Varchar, null:Varchar, null:Int32] }
        └─LogicalJoin { type: Inner, on: (rw_schemas.name = 'pg_catalog':Varchar), output: all }
          ├─LogicalSysScan { table: rw_types, columns: [rw_types.id, rw_types.name, rw_types.input_oid, rw_types.typelem, rw_types.typarray] }
          └─LogicalSysScan { table: rw_schemas, columns: [rw_schemas.id, rw_schemas.name, rw_schemas.owner, rw_schemas.acl] }
  batch_plan: |-
    BatchProject { exprs: [rw_types.id, rw_types.name, rw_types.typelem, rw_types.typarray, rw_types.input_oid, false:Boolean, 0:Int32, -1:Int32, 0:Int32, 0:Int32, rw_schemas.id, 'b':Varchar, 0:Int32, null:Varchar, null:Varchar, null:Int32] }
    └─BatchNestedLoopJoin { type: Inner, predicate: true, output: all }
      ├─BatchScan { table: rw_types, columns: [rw_types.id, rw_types.name, rw_types.input_oid, rw_types.typelem, rw_types.typarray], distribution: Single }
      └─BatchProject { exprs: [rw_schemas.id] }
        └─BatchFilter { predicate: (rw_schemas.name = 'pg_catalog':Varchar) }
          └─BatchScan { table: rw_schemas, columns: [rw_schemas.id, rw_schemas.name], distribution: Single }
- sql: |
    select * from pg_catalog.pg_namespace
  logical_plan: |-
    LogicalProject { exprs: [rw_schemas.id, rw_schemas.name, rw_schemas.owner, rw_schemas.acl] }
    └─LogicalShare { id: 2 }
      └─LogicalProject { exprs: [rw_schemas.id, rw_schemas.name, rw_schemas.owner, rw_schemas.acl] }
        └─LogicalSysScan { table: rw_schemas, columns: [rw_schemas.id, rw_schemas.name, rw_schemas.owner, rw_schemas.acl] }
  batch_plan: 'BatchScan { table: rw_schemas, columns: [rw_schemas.id, rw_schemas.name, rw_schemas.owner, rw_schemas.acl], distribution: Single }'
- sql: |
    select * from pg_catalog.pg_cast
  logical_plan: |-
    LogicalProject { exprs: [pg_cast.oid, pg_cast.castsource, pg_cast.casttarget, pg_cast.castcontext] }
    └─LogicalSysScan { table: pg_cast, columns: [pg_cast.oid, pg_cast.castsource, pg_cast.casttarget, pg_cast.castcontext] }
  batch_plan: 'BatchScan { table: pg_cast, columns: [pg_cast.oid, pg_cast.castsource, pg_cast.casttarget, pg_cast.castcontext], distribution: Single }'
- sql: |
    select pg_catalog.pg_get_userbyid(1)
  logical_plan: |-
    LogicalProject { exprs: [PgGetUserbyid(1:Int32) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
  batch_plan: |-
    BatchProject { exprs: [PgGetUserbyid(1:Int32) as $expr1] }
    └─BatchValues { rows: [[]] }
- sql: |
    select 'pg_namespace'::regclass
  logical_plan: |-
    LogicalProject { exprs: [CastRegclass('pg_namespace':Varchar) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
  batch_plan: |-
    BatchProject { exprs: [CastRegclass('pg_namespace':Varchar) as $expr1] }
    └─BatchValues { rows: [[]] }
- sql: |
    select ('pg' || '_namespace')::regclass
  logical_plan: |-
    LogicalProject { exprs: [CastRegclass(ConcatOp('pg':Varchar, '_namespace':Varchar)) as $expr1] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
  batch_plan: |-
    BatchProject { exprs: [CastRegclass('pg_namespace':Varchar) as $expr1] }
    └─BatchValues { rows: [[]] }
- sql: |
    select 'boolin'::regproc
  logical_plan: |-
    LogicalProject { exprs: ['boolin':Varchar] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
  batch_plan: 'BatchValues { rows: [[''boolin'':Varchar]] }'
