# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- name: Common sub expression extract1
  sql: |
    create table t (v1 jsonb);
    select v1->'a'->'c' x, v1->'a'->'b' y from t;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [JsonbAccessInner($expr1, 'c':Varchar) as $expr2, JsonbAccessInner($expr1, 'b':Varchar) as $expr3] }
      └─BatchProject { exprs: [t.v1, JsonbAccessInner(t.v1, 'a':Varchar) as $expr1] }
        └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [x, y, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [JsonbAccessInner($expr1, 'c':Varchar) as $expr2, JsonbAccessInner($expr1, 'b':Varchar) as $expr3, t._row_id] }
      └─StreamProject { exprs: [t.v1, JsonbAccessInner(t.v1, 'a':Varchar) as $expr1, t._row_id] }
        └─StreamTableScan { table: t, columns: [t.v1, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
- name: Common sub expression extract2
  sql: |
    create table t (v1 jsonb);
    select v1->'a'->'c' x, v1->'a'->'c' y from t;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [$expr1, $expr1] }
      └─BatchProject { exprs: [t.v1, JsonbAccessInner(JsonbAccessInner(t.v1, 'a':Varchar), 'c':Varchar) as $expr1] }
        └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [x, y, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [$expr1, $expr1, t._row_id] }
      └─StreamProject { exprs: [t.v1, JsonbAccessInner(JsonbAccessInner(t.v1, 'a':Varchar), 'c':Varchar) as $expr1, t._row_id] }
        └─StreamTableScan { table: t, columns: [t.v1, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
- name: Common sub expression shouldn't extract impure function
  sql: |
    create table t(v1 varchar, v2 int, v3 int);
    select rw_vnode(v2) + 1 as vnode,  rw_vnode(v2) + 1 as vnode2, v2 + 1 x, v2 + 1 y from t;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [(Vnode(t.v2) + 1:Int32) as $expr2, (Vnode(t.v2) + 1:Int32) as $expr3, $expr1, $expr1] }
      └─BatchProject { exprs: [t.v2, (t.v2 + 1:Int32) as $expr1] }
        └─BatchScan { table: t, columns: [t.v2], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [vnode, vnode2, x, y, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [(Vnode(t.v2) + 1:Int32) as $expr2, (Vnode(t.v2) + 1:Int32) as $expr3, $expr1, $expr1, t._row_id] }
      └─StreamProject { exprs: [t.v2, (t.v2 + 1:Int32) as $expr1, t._row_id] }
        └─StreamTableScan { table: t, columns: [t.v2, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
- name: Common sub expression shouldn't extract const
  sql: |
    SELECT x,
       tand(x),
       tand(x) IN ('-Infinity'::float8,-1,0,1,'Infinity'::float8) AS tand_exact,
       cotd(x),
       cotd(x) IN ('-Infinity'::float8,-1,0,1,'Infinity'::float8) AS cotd_exact
    FROM (VALUES (0), (45), (90), (135), (180),
    (225), (270), (315), (360)) AS t(x)
  batch_plan: |-
    BatchProject { exprs: [*VALUES*_0.column_0, $expr1, In($expr1, -Infinity:Float64, -1:Float64, 0:Float64, 1:Float64, Infinity:Float64) as $expr3, $expr2, In($expr2, -Infinity:Float64, -1:Float64, 0:Float64, 1:Float64, Infinity:Float64) as $expr4] }
    └─BatchProject { exprs: [*VALUES*_0.column_0, Tand(*VALUES*_0.column_0::Float64) as $expr1, Cotd(*VALUES*_0.column_0::Float64) as $expr2] }
      └─BatchValues { rows: [[0:Int32], [45:Int32], [90:Int32], [135:Int32], [180:Int32], [225:Int32], [270:Int32], [315:Int32], [360:Int32]] }
