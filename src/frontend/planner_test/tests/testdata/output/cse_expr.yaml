# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- name: Common sub expression extract1
  sql: |
    create table t (v1 jsonb);
    select v1->'a'->'c' x, v1->'a'->'b' y from t;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [JsonbAccessInner($expr1, 'c':Varchar) as $expr2, JsonbAccessInner($expr1, 'b':Varchar) as $expr3] }
      └─BatchProject { exprs: [t.v1, JsonbAccessInner(t.v1, 'a':Varchar) as $expr1] }
        └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [x, y, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [JsonbAccessInner($expr1, 'c':Varchar) as $expr2, JsonbAccessInner($expr1, 'b':Varchar) as $expr3, t._row_id] }
      └─StreamProject { exprs: [t.v1, JsonbAccessInner(t.v1, 'a':Varchar) as $expr1, t._row_id] }
        └─StreamTableScan { table: t, columns: [t.v1, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
- name: Common sub expression extract2
  sql: |
    create table t (v1 jsonb);
    select v1->'a'->'c' x, v1->'a'->'c' y from t;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [$expr1, $expr1] }
      └─BatchProject { exprs: [t.v1, JsonbAccessInner(JsonbAccessInner(t.v1, 'a':Varchar), 'c':Varchar) as $expr1] }
        └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [x, y, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [$expr1, $expr1, t._row_id] }
      └─StreamProject { exprs: [t.v1, JsonbAccessInner(JsonbAccessInner(t.v1, 'a':Varchar), 'c':Varchar) as $expr1, t._row_id] }
        └─StreamTableScan { table: t, columns: [t.v1, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
- name: Common sub expression shouldn't extract impure function
  sql: |
    create table t(v1 varchar, v2 int, v3 int);
    select rw_vnode(v2) + 1 as vnode,  rw_vnode(v2) + 1 as vnode2, v2 + 1 x, v2 + 1 y from t;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [(Vnode(t.v2) + 1:Int32) as $expr2, (Vnode(t.v2) + 1:Int32) as $expr3, $expr1, $expr1] }
      └─BatchProject { exprs: [t.v2, (t.v2 + 1:Int32) as $expr1] }
        └─BatchScan { table: t, columns: [t.v2], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [vnode, vnode2, x, y, t._row_id(hidden)], stream_key: [t._row_id], pk_columns: [t._row_id], pk_conflict: NoCheck }
    └─StreamProject { exprs: [(Vnode(t.v2) + 1:Int32) as $expr2, (Vnode(t.v2) + 1:Int32) as $expr3, $expr1, $expr1, t._row_id] }
      └─StreamProject { exprs: [t.v2, (t.v2 + 1:Int32) as $expr1, t._row_id] }
        └─StreamTableScan { table: t, columns: [t.v2, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
