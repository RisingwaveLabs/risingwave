// Copyright 2022 Singularity Data
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! This module contains datatypes and functions which can be generated by sqlsmith.

use std::collections::HashMap;
use std::sync::{Arc, LazyLock};

use risingwave_common::types::struct_type::StructType;
use risingwave_common::types::{DataType as RwDataType, DataTypeName};
use risingwave_expr::expr::AggKind;
use risingwave_expr::sig::agg::{agg_func_sigs, AggFuncSig as RwAggFuncSig};
use risingwave_expr::sig::cast::{cast_sigs, CastContext, CastSig as RwCastSig};
use risingwave_expr::sig::func::{func_sigs, FuncSign as RwFuncSig};
use risingwave_frontend::expr::ExprType;
use risingwave_sqlparser::ast::{DataType as AstDataType, StructField};

pub static STRUCT_FIELD_1: &str = "a";

/// Datatypes which can be generated by sqlsmith
#[derive(Debug, PartialEq, Hash, Eq, Clone, Copy)]
pub enum DataType {
    Boolean,
    Int16,
    Int32,
    Int64,
    Decimal,
    Float32,
    Float64,
    Varchar,
    Date,
    Timestamp,
    Timestamptz,
    Time,
    Interval,
    ListOfVarchar, // varchar []
    ListOfInt,     // integer []
    StructOfInt,   // struct < a integer >
}

impl DataType {
    pub fn is_scalar(&self) -> bool {
        todo!()
    }
}

impl TryFrom<&DataTypeName> for DataType {
    type Error = String;

    fn try_from(value: &DataTypeName) -> Result<Self, Self::Error> {
        (*value).try_into()
    }
}

impl TryFrom<DataTypeName> for DataType {
    type Error = String;

    fn try_from(value: DataTypeName) -> Result<Self, Self::Error> {
        use DataTypeName as T;
        match value {
            T::Boolean => Ok(DataType::Boolean),
            T::Int16 => Ok(DataType::Int16),
            T::Int32 => Ok(DataType::Int32),
            T::Int64 => Ok(DataType::Int64),
            T::Decimal => Ok(DataType::Decimal),
            T::Float32 => Ok(DataType::Float32),
            T::Float64 => Ok(DataType::Float64),
            T::Varchar => Ok(DataType::Varchar),
            T::Date => Ok(DataType::Date),
            T::Timestamp => Ok(DataType::Timestamp),
            T::Timestamptz => Ok(DataType::Timestamptz),
            T::Time => Ok(DataType::Time),
            T::Interval => Ok(DataType::Interval),
            _ => Err(format!("Invalid type: {:?}", value)),
        }
    }
}

impl TryFrom<RwDataType> for DataType {
    type Error = String;

    fn try_from(value: RwDataType) -> Result<Self, Self::Error> {
        use RwDataType as T;
        match value {
            T::Boolean => Ok(Self::Boolean),
            T::Int16 => Ok(Self::Int16),
            T::Int32 => Ok(Self::Int32),
            T::Int64 => Ok(Self::Int64),
            T::Decimal => Ok(Self::Decimal),
            T::Float32 => Ok(Self::Float32),
            T::Float64 => Ok(Self::Float64),
            T::Varchar => Ok(Self::Varchar),
            T::Date => Ok(Self::Date),
            T::Timestamp => Ok(Self::Timestamp),
            T::Timestamptz => Ok(Self::Timestamptz),
            T::Time => Ok(Self::Time),
            T::Interval => Ok(Self::Interval),
            T::List { datatype: d } if *d == RwDataType::Int32 => Ok(Self::ListOfInt), /* integer [] */
            T::List { datatype: d } if *d == RwDataType::Varchar => Ok(Self::ListOfVarchar), /* varchar [] */
            T::Struct(ref s)
                if s.fields == vec![RwDataType::Int32] && s.field_names == vec![STRUCT_FIELD_1] =>
            {
                Ok(Self::StructOfInt)
            } /* struct < a integer > */
            _ => Err(format!("Invalid type: {:?}", value)),
        }
    }
}

/// Sqlsmith [`DataType`] is subset of [`AstDataType`], so we can have a `From` trait.
impl From<DataType> for AstDataType {
    fn from(value: DataType) -> Self {
        use DataType as T;
        match value {
            T::Boolean => Self::Boolean,
            T::Int16 => Self::SmallInt(None),
            T::Int32 => Self::Int(None),
            T::Int64 => Self::BigInt(None),
            T::Decimal => Self::Decimal(None, None),
            T::Float32 => Self::Float(Some(32)),
            T::Float64 => Self::Float(Some(64)),
            T::Varchar => Self::Varchar,
            T::Date => Self::Date,
            T::Timestamp => Self::Timestamp(false),
            T::Timestamptz => Self::Timestamp(true),
            T::Time => Self::Time(false),
            T::Interval => Self::Interval,
            T::ListOfVarchar => Self::Array(Box::new(Self::Varchar)), // varchar []
            T::ListOfInt => Self::Array(Box::new(Self::Int(None))),   // integer []
            T::StructOfInt => Self::Struct(vec![StructField {
                name: STRUCT_FIELD_1.into(),
                data_type: Self::Int(None),
            }]), /* struct < STRUCT_FIELD_1
                                                                        * integer > */
        }
    }
}

/// Sqlsmith [`DataType`] is subset of [`RwDataType`], so we can have a `From` trait.
impl From<DataType> for RwDataType {
    fn from(value: DataType) -> Self {
        use DataType as T;
        match value {
            T::Boolean => Self::Boolean,
            T::Int16 => Self::Int16,
            T::Int32 => Self::Int32,
            T::Int64 => Self::Int64,
            T::Decimal => Self::Decimal,
            T::Float32 => Self::Float32,
            T::Float64 => Self::Float64,
            T::Varchar => Self::Varchar,
            T::Date => Self::Date,
            T::Timestamp => Self::Timestamp,
            T::Timestamptz => Self::Timestamptz,
            T::Time => Self::Time,
            T::Interval => Self::Interval,
            T::ListOfVarchar => Self::List {
                datatype: Box::new(Self::Varchar),
            },
            T::ListOfInt => Self::List {
                datatype: Box::new(Self::Varchar),
            }, // integer []
            T::StructOfInt => Self::Struct(Arc::new(StructType {
                fields: vec![Self::Int32],
                field_names: vec![STRUCT_FIELD_1.into()],
            })), // struct < a integer >
        }
    }
}

#[derive(Clone)]
pub struct CastSig {
    pub from_type: DataType,
    pub to_type: DataType,
    pub context: CastContext,
}

#[derive(Clone)]
pub struct FuncSig {
    pub func: ExprType,
    pub inputs_type: Vec<DataType>,
    pub ret_type: DataType,
}

#[derive(Clone)]
pub struct AggFuncSig {
    pub func: AggKind,
    pub inputs_type: Vec<DataType>,
    pub ret_type: DataType,
}

impl TryFrom<RwCastSig> for CastSig {
    type Error = String;

    fn try_from(value: RwCastSig) -> Result<Self, Self::Error> {
        if let Ok(from_type) = value.from_type.try_into()
            && let Ok(to_type) = value.to_type.try_into() {
            Ok(CastSig {
                from_type,
                to_type,
                context: value.context,
            })
        } else {
            Err(format!("unsupported cast sig: {:?}", value))
        }
    }
}

impl TryFrom<&RwFuncSig> for FuncSig {
    type Error = String;

    fn try_from(value: &RwFuncSig) -> Result<Self, Self::Error> {
        if let Ok(inputs_type) = value.inputs_type.iter().map(|i| i.try_into()).collect()
            && let Ok(ret_type) = value.ret_type.try_into() {
            Ok(FuncSig {
                inputs_type,
                ret_type,
                func: value.func,
            })
        } else {
            Err(format!("unsupported func sig: {:?}", value))
        }
    }
}

impl TryFrom<&RwAggFuncSig> for AggFuncSig {
    type Error = String;

    fn try_from(value: &RwAggFuncSig) -> Result<Self, Self::Error> {
        if let Ok(inputs_type) = value.inputs_type.iter().map(|i| i.try_into()).collect()
            && let Ok(ret_type) = value.ret_type.try_into() {
            Ok(AggFuncSig {
                inputs_type,
                ret_type,
                func: value.func,
            })
        } else {
            Err(format!("unsupported agg_func sig: {:?}", value))
        }
    }
}

/// Table which maps functions' return types to possible function signatures.
pub(crate) static FUNC_TABLE: LazyLock<HashMap<DataType, Vec<FuncSig>>> = LazyLock::new(|| {
    let mut funcs = HashMap::<DataType, Vec<FuncSig>>::new();
    func_sigs()
        .filter_map(|func| func.try_into().ok())
        .for_each(|func: FuncSig| funcs.entry(func.ret_type).or_default().push(func));
    funcs
});

/// Table which maps aggregate functions' return types to possible function signatures.
pub(crate) static AGG_FUNC_TABLE: LazyLock<HashMap<DataType, Vec<AggFuncSig>>> =
    LazyLock::new(|| {
        let mut funcs = HashMap::<DataType, Vec<AggFuncSig>>::new();
        agg_func_sigs()
            .filter_map(|func| func.try_into().ok())
            .for_each(|func: AggFuncSig| funcs.entry(func.ret_type).or_default().push(func));
        funcs
    });

/// Build a cast map from return types to viable cast-signatures.
/// NOTE: We avoid cast from varchar to other datatypes apart from itself.
/// This is because arbitrary strings may not be able to cast,
/// creating large number of invalid queries.
pub(crate) static CAST_TABLE: LazyLock<HashMap<DataType, Vec<CastSig>>> = LazyLock::new(|| {
    let mut casts = HashMap::<DataType, Vec<CastSig>>::new();
    cast_sigs()
        .filter_map(|cast| cast.try_into().ok())
        .filter(|cast: &CastSig| {
            cast.context == CastContext::Explicit || cast.context == CastContext::Implicit
        })
        .filter(|cast| cast.from_type != DataType::Varchar || cast.to_type == DataType::Varchar)
        .for_each(|cast| casts.entry(cast.to_type).or_default().push(cast));
    casts
});
